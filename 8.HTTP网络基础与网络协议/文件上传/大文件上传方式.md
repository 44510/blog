# 大文件上传，大文件的特殊性在于大，需要上传很久，或者中途会出错，multipart/form-data

1. 为什么要区分大文件的上传：
   1. 当上传大文件时，可能会遇见请求超时的情形；
   2. 大文件上传最主要的问题就在于：在同一个请求中，要上传大量的数据，导致整个过程会比较漫长，且失败后需要重头开始上传。
2. 切片分段上传，需要具备什么能力&如何实现：
   1. 支持拆分上传请求(即切片)；
      1. 在 JavaScript 中，**文件 FIle 对象是 Blob 对象的子类，Blob 对象包含一个重要的方法 slice，通过这个方法，我们就可以对二进制文件进行拆分**；
         1. 获取文件`document.querySelector("[name=file]").files[0]`；
         2. `slice(file, LENGTH); // 首先拆分切片`，文件分片，可以理解为对一段字符串进行分割，**File 对象继承自 Blob 对象，因此包含 slice 方法**；
         3. 然后构造 formData：`new FormData();fd.append("file", chunk);；
         4. `post('/mkblk.php', fd)`，发送到服务端；
      2. 服务器接收到这些切片后，再将他们拼接起来就可以了；
      3. 这里有一个问题，就是如何标记当前的分片文件，可以使用分片的 index 作为 id 进行上传，然后所有 id 在被后端接收完成后，按照数组方式再拼装。
         1. 所有切片上传完毕后，调用 mkfile 接口：`Promise.all(tasks).then(res => {`，告诉后端的总的数量，这个请求结束后就可以拼装文件了；
   2. 支持断点续传；
      1. **在切片上传成功后，保存已上传的切片信息**；
      2. **当下次传输相同文件时，遍历切片列表，只选择未上传的切片进行上传**；
         1. 因此问题就落在了如何保存已上传切片的信息了，保存一般有两种策略：
            1. locaStorage 等方式保存在前端浏览器中；
            2. 服务端本身知道哪些切片已经上传，因此可以由服务端额外提供一个根据文件 context 查询已上传切片的接口，在上传文件前调用该文件的历史上传记录；
      3. 所有切片上传完毕后，再调用 mkfile 接口通知服务端进行文件合并。
   3. 支持显示上传进度和暂停上传。
      1. 上传暂停的实现也比较简单，通过 xhr.abort 可以取消当前未完成上传切片的上传。
3. 总结就是大文件上传：
   1. multipart/form-data；
   2. 通过 Blob 对象的 slice 方法将文件拆分成切片；
   3. 其他的问题：
      1. **文件多并发的问题**，可以同时只开 6 个任务来上传，有成功的完成之后，再继续后边的，类似瀑布流；
      2. 切片文件上传失败，需要支持断点重传；
      3. chunk 需要定时清理；
