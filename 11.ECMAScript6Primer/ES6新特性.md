### 怎么区分是 es5 还是 es6，处理浏览器兼容性问题

### es6 的 generator 是什么，async/await 的实现原理

处理集合中的每个项是很常见的操作。

JavaScript 提供了许多迭代集合的方法，从简单的 for 循环到 map()和 filter()。

迭代器和生成器将迭代的概念直接带入核心语言，并提供了一种机制来自定义 for...of 循环的行为 。

一个迭代器对象 ，知道如何每次访问集合中的一项， 并跟踪该序列中的当前位置。

在 JavaScript 中 迭代器是一个对象，它提供了一个 next() 方法，用来返回序列中的下一项。

这个方法返回包含两个属性：done 和 value。

基本上就达到了同步转异步的行为了。编译之后，写在了回调函数内部。

### ES6 和 node 的 commonjs 模块化规范区别

模块化规范：即为 JavaScript 提供一种模块编写、模块依赖和模块运行的方案。谁让最初的 JavaScript 是那么的裸奔呢——全局变量就是它的模块化规范。

require/exports 出生在野生规范当中，什么叫做野生规范？即这些规范是 JavaScript 社区中的开发者自己草拟的规则，得到了大家的承认或者广泛的应用。

比如 CommonJS、AMD、CMD 等等。import/export 则是名门正派。TC39 制定的新的 ECMAScript 版本，即 ES6（ES2015）中包含进来。

[CommonJS 模块与 ES6 模块的区别](https://www.cnblogs.com/unclekeith/archive/2017/10/17/7679503.html)

需要添加测试。

#### CommonJS

```js
module.export =
export =
require();
```

1. 对于**基本数据类型，属于复制**。即会被**模块缓存**。同时，在另一个模块可以对该模块输出的变量重新赋值。
2. 对于**复杂数据类型，属于浅拷贝**。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时**会影响另一个模块**。
3. 当使用 require 命令加载某个模块时，就会运行整个模块的代码。
4. 当使用 require 命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。
5. 循环加载时，属于加载时执行。即脚本代码在 require 的时候，就会全部执行。一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。
