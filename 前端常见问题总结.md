# 前端常见问题总结

这里对当前 blog 进行一个梳理。

## 分析问题

### 是什么，为什么，具体内容有什么

- 为什么，why
- 是什么，what
- 具体的呢，detail

## js

### [js 数据类型](./0.5.JS/BLOG-js数据类型.md)

### [执行环境和作用域链](./0.5.JS/BLOG-执行环境和作用域链.md)

### [闭包](./0.5.JS/BLOG-闭包.md)

### [JS 模块化](./0.5.JS/JS模块化/BLOG-JS模块化.md)

### [原型与原型链及对象创建以及继承](./0.5.JS/原型与原型链与类及对象创建/BLOG-原型与原型链及对象创建以及继承.md)

### [js 的事件循环机制](./0.5.JS/BLOG-JavaScript执行机制.md)

### ES6 基础语法

- 对象扩展，`let obj = {a,b}`
- 数组扩展，Array.from，类数组转数组`return Array.from ? Array.from : (obj) => [].slice.call(obj);`、fill、from、flat、entries()，keys() 和 values()、
- 字符串的扩展，includes、模板字符串
  - 字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和 split()。
- 正则的扩展
  - 正则表达式 RegExp 的 **exec**(->match) 和 **test** 方法。
- let/const，块作用域，不存在变量提升的问题
- 解构赋值，对象解构、数组解构，函数参数解构
- 箭头函数
- decorator 装饰器，类的修饰，方法的修饰
- class
- generator，生成器函数，\* yield next()
- async...await
- Proxy
- for...of

#### [箭头函数与一般函数中 this 的指向问题](./0.5.JS/BLOG-js中this指向的问题.md)

#### 正则表达式的方法使用

```js
const reg = /quick\s(brown).+?(jumps)/gi;
const str = 'The Quick Brown Fox Jumps Over The Lazy Dog';
reg.exec(str);
reg.test(str);

str.match(reg);
str.split(reg);
str.replace(reg, (match, p1, p2) => {
  console.log(match, p1, p2);
});
```

## CSS

### [CSS 盒模型及 BFC](./0.3.CSS/BLOG-CSS盒模型及BFC.md)

### [布局方式](./12.前端页面布局/)

- 标准文档流布局
- table 布局
- float 布局
- flex 布局
- grid 布局

### [元素水平垂直居中问题](./12.前端页面布局/元素水平垂直居中问题.html)

1. margin: auto; 配合设置定位 absolute 都是 0，自动计算外边距居中；
2. display: table-cell;，table 布局。
3. transform(相对于自身大小，进行微调) + 定位 absolute(大的调整)；
4. flex 布局，align-items: center;justify-content: center;

#### transform，top，margin 的百分比参照

- transform 是相对于**自身的宽高**。
- top 相对于父元素的高度。
- 这里的 **margin 是相对于父级元素的宽度**，margin-top 也是相对于宽度的。

### [选择器，伪类，伪元素](./0.3.CSS/BLOG-css选择器，伪类，伪元素.md)

#### 选择方法

- document.querySelector、document.querySelectorAll
- document.getElementById
- getElementsByClassName
- getElementsByName
- getElementsByTagName

### [前端动画操作](./0.2.HTML/html动画操作/BLOG-前端动画操作.md)

## 浏览器原理

### [浏览器渲染过程|从输入 url 到页面加载完成的过程都发生了什么](./3.浏览器原理/从输入url到页面加载完成的过程都发生了什么/BLOG-从输入url到页面加载完成的过程都发生了什么.md)

### [浏览器缓存](./3.浏览器原理/浏览器的缓存机制/BLOG-浏览器缓存.md)

## [React 和 redux](../react-learn/blog-react/BLOG-React.md)

### [各种库与框架的设计思想和工作原理](./10.各种库与框架的设计思想和工作原理)

### [组件化和模块化](./10.各种库与框架的设计思想和工作原理/BLOG-组件化和模块化.md)

### react，setState，连续两次 setState，888 行

- 数据合并更改 -> 渲染流程。
- 批量合并再去渲染。
- 把新的`state`存到一个**队列**（`batchUpdate`）中
- 把`setState()` 看作是重新 render 的**一次请求**而不是立刻更新组件的指令。
- 那么调用 this.setState()后，什么时候 this.state 才会更新，答案是**即将要执行下一次的`render`函数时**。

注意区分两种类型的操作：(区分是不是能合并渲染)

- **生命周期和合成事件中**，表现异步，合并执行 rerender
- **异步代码和原生事件中**以及 setTimeout/setInterval 等原生 API 中，表现同步，立即执行 rerender

### react 生命周期

- 挂载阶段
  - `constructor`
  - `static getDerivedStateFromProps(props, state)`
  - `render`
  - `componentDidMount`
- 更新阶段
  - `static getDerivedStateFromProps(props, state)`
  - `shouldComponentUpdate(nextProps, nextState)`，性能优化，PureComponent
  - `render`
  - `getSnapshotBeforeUpdate(prevProps, prevState)`
  - `componentDidUpdate`
- 卸载阶段
  - `componentWillUnmount`
- 错误处理
  - `static getDerivedStateFromError()`
  - `componentDidCatch`

### HOC 高阶组件

- 高阶组件就是一个函数，且该函数**接受一个组件作为参数**，**并返回一个新的组件**。
- 对组件逻辑进行复用的高级技术
- 对比组件将 props 属性转变成 UI，**高阶组件则是将一个组件转换成另一个新组件**。

`HOC`在业务中的**实际应用场景**：

- 日志打点
- 权限控制
- 双向绑定
- 表单校验

#### React 高阶组件的写法，通常有哪几种

- 属性代理，第一种是通过**工厂模式**直接 wrapper，操作组件的 props；
- 反向继承，第二种是通过**组件反向继承**的方式，拦截生命周期、state、渲染过程。

[具体 demo，查看](./react-features-test/src/pages/hoc)

### diff 算法，React Fiber

真实 dom -> jsx 虚拟 dom -> 数据更改(props/setState) -> 新的虚拟 dom -> diff 计算(Fiber Reconciler) -> 真实 dom 重新 render。

Fiber Reconciler 算法：

- 负责调用组件生命周期方法
- 进行 Diff 运算
- 将要执行的 **JS 做拆分**，保证不会阻塞主线程（Main thread）即可
- 实现了自己的**组件调用栈**，可以灵活的暂停、继续和丢弃执行的任务

### react 的性能优化方案

- 重写`shouldComponentUpdate`来避免不必要的 dom 操作
- 使用 production 版本的 react.js
- 使用 key **来帮助 React 识别列表中所有子组件的最小变化**
- 无引用类型状态的时候，尽量使用纯组件，PureComponent
- 懒加载组件
- 为组件创建错误边界
- 用 CSS 动画代替 JavaScript 动画

### 组件懒加载

- React.lazy()配合 Suspense 实现
- 代码包进行分割，每个 lazy 组件，单独打包成一个文件

### React 中 keys 的作用是什么

- keys 是 React 用于**追踪哪些列表中元素被修改**、**被添加或者被移除的辅助标识**。
- 同级元素中具有唯一性

### hook 使用及优缺点

```jsx
const [count, setCount] = useState(0);

useEffect(() => {
  // Update the document title using the browser API
  document.title = `You clicked ${count} times`;
});
```

### 组件的封装

组件允许你将 UI 拆分为**独立可复用的代码片段**，并对每个片段进行独立构思。

- 复用，考虑可能用到的场景，可扩展性
- **封装性**，不影响到别的组件
- 默认值，**易用性**
- 一个组件只专注于一件事

### 无状态组件与 class 组件的选择

#### 定义一个组件时候，如何决定要用 Functional(stateLess) 还是 Class

- 简单的用 Functional，复杂的用 Class
- **不需要组件内状态的用 Functional**，当做纯的渲染模版。需要的用 Class，不过出现 hook 之后，无状态组件也可以添加内部状态，并且有副作用函数钩子。

#### 为什么对于使用 react, 总说 Function Component 是最轻量的呢

- **轻量是对于 js 解析过程中的开销来说的**，**函数式组件不需要创建 class 所必需的一些对象，方法等，只需要拿到数据，然后组装就好了**。
- 函数组件**不需要 new 来生成实例**；
- 函数组件**不需要挂载生命周期**。

### redux 相关

Redux 是 JavaScript 状态容器，提供可预测化的状态管理。

三大原则

- **单一数据源**
- **State 是只读**的，只能通过 action 来触发，store.dispatch
- 使用**纯函数来执行修改**，不会产生副作用，reducers

### redux 原理，主要接口

### 对比 mobx 及其他的状态管理工具

### 熟练掌握 React/Redux，深入了解技术原理

#### [Redux](https://www.redux.org.cn/docs/basics/Actions.html)

<details>
  <summary>是什么？</summary>
  <p>Redux 是 JavaScript <b>状态容器，只要你的项目中使用到了状态，并且状态十分复杂，那么你就可以使用</b> Redux 管理你的项目状态，它可以使用在 react 中，也可以使用中在 Vue 中，当然也适用其他的框架。</p>
</details>

<details>
  <summary>redux的主要构成模块</summary>
  <ul>
    <li>action: 动作，ui -> </li>
  </u>
</details>

- 遵循 Flux(Dispatcher-Store-View)规范
  - 修改数据，**Action**->**Dispatcher**->**Store**->**View**
  - 数据修改，View->Action
  - Facebook 为了解决在 MVC 应用中碰到的工程性问题提出一个架构思想
  - 基于一个简单的原则：**数据在应用中单向流动（单向数据流）**
  - React(Flux 中 View，只关注表现层)

## [webpack](./9.前端构建工具及实例/webpack)

- webpack4 利用 import **动态加载**的一些说明

### webpack 优化策略，提高 dev 及 build 的速度

使用工具分析各部分执行时常，BundleAnalyzerPlugin

- cache-loader，插件开启，缓存及并行。
- 开启多核编译，提高速度，HappyPack
- 抽离，webpack-dll-plugin
- Externals，外部文件，单独引入，如jquery
- 以及拆分，每一个子模块都被拆分成了一个单独的 repo
- 如何更好地优化打包资源，减小体积，代码压缩，MiniCssExtractPlugin，UglifyJsPlugin

## 版本管理工具

### 常用的 git 命令有哪些

- git config
- git init
- git clone
- git status
- git add
- git commit
- git push
- git pull
- git branch
- git rebase
- git feature start branch_name
- git release start branch_name

### 常见问题处理

**谈谈你对重构的理解**

- 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变 UI 的情况下，对网站进行优化， 在扩展的同时保持一致的 UI

- 对于传统的网站来说重构通常是：

  - 表格(table)布局改为 DIV+CSS

  - 使网站前端兼容于现代浏览器(针对于不合规范的 CSS、如对 IE6 有效的)

  - 对于移动平台的优化

  - 针对于 SEO 进行优化

  - 深层次的网站重构应该考虑的方面

**页面重构怎么操作？**

- 网站重构：不改变 UI 的情况下，对网站进行优化，在扩展的同时保持一致的 UI。

- 页面重构可以考虑的方面：
  - 升级第三方依赖
  - 使用 HTML5、CSS3、ES6 新特性
  - 加入响应式布局
  - 统一代码风格规范
  - 减少代码间的耦合
  - 压缩/合并静态资源
  - 程序的性能优化
  - 采用 CDN 来加速资源加载
  - 对于 JS DOM 的优化
  - HTTP 服务器的文件缓存

## 介绍一下 Electron

# 别人的面试题目列表

阿里

使用过的 koa2 中间件
koa-body 原理
介绍自己写过的中间件
有没有涉及到 Cluster
介绍 pm2
master 挂了的话 pm2 怎么处理
如何和 MySQL 进行通信
React 声明周期及自己的理解
如何配置 React-Router
路由的动态加载模块
服务端渲染 SSR
介绍路由的 history
介绍 Redux 数据流的流程
Redux 如何实现多个组件之间的通信，多个组件使用相同状态如何进行管理
多个组件之间如何拆分各自的 state，每块小的组件有自己的状态，它们之间还有一些公共的状态需要维护，如何思考这块
使用过的 Redux 中间件
如何解决跨域的问题
常见 Http 请求头
移动端适配 1px 的问题
介绍 flex 布局
其他 css 方式设置垂直居中
居中为什么要使用 transform（为什么不使用 marginLeft/Top）
使用过 webpack 里面哪些 plugin 和 loader
webpack 里面的插件是怎么实现的
dev-server 是怎么跑起来
项目优化
抽取公共文件是怎么配置的
项目中如何处理安全问题
怎么实现 this 对象的深拷贝

网易

介绍 redux，主要解决什么问题
文件上传如何做断点续传
表单可以跨域吗
promise、async 有什么区别
搜索请求如何处理（防抖）
搜索请求中文如何请求
介绍观察者模式
介绍中介者模式
观察者和订阅-发布的区别，各自用在哪里
介绍 react 优化
介绍 http2.0
通过什么做到并发请求
http1.1 时如何复用 tcp 连接
介绍 service worker
介绍 css3 中 position:sticky
redux 请求中间件如何处理并发
介绍 Promise，异常捕获
介绍 position 属性包括 CSS3 新增
浏览器事件流向
介绍事件代理以及优缺点
React 组件中怎么做事件代理
React 组件事件代理的原理
介绍 this 各种情况
前端怎么控制管理路由
使用路由时出现问题如何解决
React 怎么做数据的检查和变化

滴滴

react-router 怎么实现路由切换
react-router 里的<Link>标签和<a>标签有什么区别
<a>标签默认事件禁掉之后做了什么才实现了跳转
React 层面的性能优化
整个前端性能提升大致分几类
import { Button } from 'antd'，打包的时候只打包 button，分模块加载，是怎么做到的
使用 import 时，webpack 对 node_modules 里的依赖会做什么
JS 异步解决方案的发展历程以及优缺点
Http 报文的请求会有几个部分
cookie 放哪里，cookie 能做的事情和存在的价值
cookie 和 token 都存放在 header 里面，为什么只劫持前者
cookie 和 session 有哪些方面的区别
React 中 Dom 结构发生变化后内部经历了哪些变化
React 挂载的时候有 3 个组件，textComponent、composeComponent、domComponent，区别和关系，Dom 结构发生变化时怎么区分 data 的变化，怎么更新，更新怎么调度，如果更新的时候还有其他任务存在怎么处理
key 主要是解决哪一类的问题，为什么不建议用索引 index（重绘）
Redux 中异步的请求怎么处理
Redux 中间件是什么东西，接受几个参数（两端的柯里化函数）
柯里化函数两端的参数具体是什么东西
中间件是怎么拿到 store 和 action，然后怎么处理
state 是怎么注入到组件的，从 reducer 到组件经历了什么样的过程
koa 中 response.send、response.rounded、response.json 发生了什么事，浏览器为什么能识别到它是一个 json 结构或是 html
koa-bodyparser 怎么来解析 request
webpack 整个生命周期，loader 和 plugin 有什么区别
介绍 AST（Abstract Syntax Tree）抽象语法树
安卓 Activity 之间数据是怎么传递的
安卓 4.0 到 6.0 过程中 WebView 对 js 兼容性的变化
WebView 和原生是如何通信
跨域怎么解决，有没有使用过 Apache 等方案

今日头条

对 async、await 的理解，内部原理
介绍下 Promise，内部实现
清除浮动
定位问题（绝对定位、相对定位等）
从输入 URL 到页面加载全过程
tcp3 次握手
tcp 属于哪一层（1 物理层 -> 2 数据链路层 -> 3 网络层(ip)-> 4 传输层(tcp) -> 5 应用层(http)）
redux 的设计思想
接入 redux 的过程
绑定 connect 的过程
connect 原理
webpack 介绍
== 和 ===的区别，什么情况下用相等==
bind、call、apply 的区别
动画的了解
介绍下原型链（解决的是继承问题吗）
对跨域的了解

有赞

Linux 754 介绍
介绍冒泡排序，选择排序，冒泡排序如何优化
transform 动画和直接使用 left、top 改变位置有什么优缺点
如何判断链表是否有环
介绍二叉搜索树的特点
介绍暂时性死区
ES6 中的 map 和原生的对象有什么区别
观察者和发布-订阅的区别
react 异步渲染的概念,介绍 Time Slicing 和 Suspense
16.X 声明周期的改变
16.X 中 props 改变后在哪个生命周期中处理
介绍纯函数
前端性能优化
pureComponent 和 FunctionComponent 区别
介绍 JSX
如何做 RN 在安卓和 IOS 端的适配
RN 为什么能在原生中绘制成原生组件（bundle.js）
介绍虚拟 DOM
如何设计一个 localStorage，保证数据的实效性
如何设计 Promise.all()
介绍高阶组件
sum(2, 3)实现 sum(2)(3)的效果
react 性能优化
两个对象如何比较

挖财

JS 的原型
变量作用域链
call、apply、bind 的区别
防抖和节流的区别
介绍各种异步方案
react 生命周期
介绍 Fiber
前端性能优化
介绍 DOM 树对比
react 中的 key 的作用
如何设计状态树
介绍 css，xsrf
http 缓存控制
项目中如何应用数据结构
native 提供了什么能力给 RN
如何做工程上的优化
shouldComponentUpdate 是为了解决什么问题
如何解决 props 层级过深的问题
前端怎么做单元测试
webpack 生命周期
webpack 打包的整个过程
常用的 plugins
pm2 怎么做进程管理，进程挂掉怎么处理
不用 pm2 怎么做进程管理

沪江

介绍下浏览器跨域
怎么去解决跨域问题
jsonp 方案需要服务端怎么配合
Ajax 发生跨域要设置什么（前端）
加上 CORS 之后从发起到请求正式成功的过程
xsrf 跨域攻击的安全性问题怎么防范
使用 Async 会注意哪些东西
Async 里面有多个 await 请求，可以怎么优化（请求是否有依赖）
Promise 和 Async 处理失败的时候有什么区别
Redux 在状态管理方面解决了 React 本身不能解决的问题
Redux 有没有做过封装
react 生命周期，常用的生命周期
对应的生命周期做什么事
遇到性能问题一般在哪个生命周期里解决
怎么做性能优化（异步加载组件...）
写 react 有哪些细节可以优化
React 的事件机制（绑定一个事件到一个组件上）
介绍下事件代理，主要解决什么问题
前端开发中用到哪些设计模式
React/Redux 中哪些功能用到了哪些设计模式
JS 变量类型分为几种，区别是什么
JS 里垃圾回收机制是什么，常用的是哪种，怎么处理的
一般怎么组织 CSS（Webpack）

饿了么

小程序里面开页面最多多少
React 子父组件之间如何传值
Emit 事件怎么发，需要引入什么
介绍下 React 高阶组件，和普通组件有什么区别
一个对象数组，每个子对象包含一个 id 和 name，React 如何渲染出全部的 name
在哪个生命周期里写
其中有几个 name 不存在，通过异步接口获取，如何做
渲染的时候 key 给什么值，可以使用 index 吗，用 id 好还是 index 好
webpack 如何配 sass，需要配哪些 loader
配 css 需要哪些 loader
如何配置把 js、css、html 单独打包成一个文件
div 垂直水平居中（flex、绝对定位）
两个元素块，一左一右，中间相距 10 像素
上下固定，中间滚动布局如何实现
[1, 2, 3, 4, 5]变成[1, 2, 3, a, b, 5]
取数组的最大值（ES5、ES6）
apply 和 call 的区别
ES5 和 ES6 有什么区别
some、every、find、filter、map、forEach 有什么区别
上述数组随机取数，每次返回的值都不一样
如何找 0-5 的随机数，95-99 呢
页面上有 1 万个 button 如何绑定事件
如何判断是 button
页面上生成一万个 button，并且绑定事件，如何做（JS 原生操作 DOM）
循环绑定时的 index 是多少，为什么，怎么解决
页面上有一个 input，还有一个 p 标签，改变 input 后 p 标签就跟着变化，如何处理
监听 input 的哪个事件，在什么时候触发

携程

对 React 看法，有没有遇到一些坑
对闭包的看法，为什么要用闭包
手写数组去重函数
手写数组扁平化函数
介绍下 Promise 的用途和性质
Promise 和 Callback 有什么区别
React 生命周期
两道手写算法题

喜马拉雅

ES6 新的特性
介绍 Promise
Promise 有几个状态
说一下闭包
React 的生命周期
componentWillReceiveProps 的触发条件是什么
React16.3 对生命周期的改变
介绍下 React 的 Filber 架构
画 Filber 渲染树
介绍 React 高阶组件
父子组件之间如何通信
Redux 怎么实现属性传递，介绍下原理
React-Router 版本号
网站 SEO 怎么处理
介绍下 HTTP 状态码
403、301、302 是什么
缓存相关的 HTTP 请求头
介绍 HTTPS
HTTPS 怎么建立安全通道
前端性能优化（JS 原生和 React）
用户体验做过什么优化
对 PWA 有什么了解
对安全有什么了解
介绍下数字签名的原理
前后端通信使用什么方案
RESTful 常用的 Method
介绍下跨域
Access-Control-Allow-Origin 在服务端哪里配置
csrf 跨站攻击怎么解决
前端和后端怎么联调

兑吧

localStorage 和 cookie 有什么区别
CSS 选择器有哪些
盒子模型，以及标准情况和 IE 下的区别
如何实现高度自适应
prototype 和——proto——区别
\_construct 是什么
new 是怎么实现的
promise 的精髓，以及优缺点
如何实现 H5 手机端的适配
rem、flex 的区别（root em）
em 和 px 的区别
React 声明周期
如何去除 url 中的#号
Redux 状态管理器和变量挂载到 window 中有什么区别
webpack 和 gulp 的优缺点
如何实现异步加载
如何实现分模块打包（多入口）
前端性能优化（1js css；2 图片；3 缓存预加载； 4 SSR； 5 多域名加载；6 负载均衡）
并发请求资源数上限（6 个）
base64 为什么能提升性能，缺点
介绍 webp 这个图片文件格式
介绍 koa2
Promise 如何实现的
异步请求，低版本 fetch 如何低版本适配
ajax 如何处理跨域
CORS 如何设置
jsonp 为什么不支持 post 方法
介绍同源策略
React 使用过的一些组件
介绍 Immuable
介绍下 redux 整个流程原理
介绍原型链
如何继承

微医

介绍 JS 数据类型，基本数据类型和引用数据类型的区别
Array 是 Object 类型吗
数据类型分别存在哪里
var a = {name: "前端开发"}; var b = a; a = null 那么 b 输出什么
var a = {b: 1}存放在哪里
var a = {b: {c: 1}}存放在哪里
栈和堆的区别
垃圾回收时栈和堆的区别
数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多少
栈和堆具体怎么存储
介绍闭包以及闭包为什么没清除
闭包的使用场景
JS 怎么实现异步
异步整个执行周期
Promise 的三种状态
Async/Await 怎么实现
Promise 和 setTimeout 执行先后的区别
JS 为什么要区分微任务和宏任务
Promise 构造函数是同步还是异步执行，then 呢
发布-订阅和观察者模式的区别
JS 执行过程中分为哪些阶段
词法作用域和 this 的区别
平常是怎么做继承
深拷贝和浅拷贝
loadsh 深拷贝实现原理
ES6 中 let 块作用域是怎么实现的
React 中 setState 后发生了什么
setState 为什么默认是异步
setState 什么时候是同步的
为什么 3 大框架出现以后就出现很多 native（RN）框架（虚拟 DOM）
虚拟 DOM 主要做了什么
虚拟 DOM 本身是什么（JS 对象）
304 是什么
打包时 Hash 码是怎么生成的
随机值存在一样的情况，如何避免
使用 webpack 构建时有无做一些自定义操作
webpack 做了什么
a，b 两个按钮，点击 aba，返回顺序可能是 baa，如何保证是 aba（Promise.then）
node 接口转发有无做什么优化
node 起服务如何保证稳定性，平缓降级，重启等
RN 有没有做热加载
RN 遇到的兼容性问题
RN 如何实现一个原生的组件
RN 混原生和原生混 RN 有什么不同
什么是单页项目
遇到的复杂业务场景
Promise.all 实现原理

寺库

介绍 Promise 的特性，优缺点
介绍 Redux
RN 的原理，为什么可以同时在安卓和 IOS 端运行
RN 如何调用原生的一些功能
介绍 RN 的缺点
介绍排序算法和快排原理
堆和栈的区别
介绍闭包
闭包的核心是什么
网络的五层模型
HTTP 和 HTTPS 的区别
HTTPS 的加密过程
介绍 SSL 和 TLS
介绍 DNS 解析
JS 的继承方法
介绍垃圾回收
cookie 的引用为了解决什么问题
cookie 和 localStorage 的区别
如何解决跨域问题
前端性能优化

宝宝树

使用 canvas 绘图时如何组织成通用组件
formData 和原生的 ajax 有什么区别
介绍下表单提交，和 formData 有什么关系
介绍 redux 接入流程
rudux 和全局管理有什么区别（数据可控、数据响应）
RN 和原生通信
介绍 MVP 怎么组织
介绍异步方案
promise 如何实现 then 处理
koa2 中间件原理
常用的中间件
服务端怎么做统一的状态处理
如何对相对路径引用进行优化
node 文件查找优先级
npm2 和 npm3+有什么区别

海康威视

knex 连接数据库响应回调
介绍异步方案
如何处理异常捕获
项目如何管理模块
前端性能优化
JS 继承方案
如何判断一个变量是不是数组
变量 a 和 b，如何交换
事件委托
多个<li>标签生成的 Dom 结构是一个类数组
类数组和数组的区别
dom 的类数组如何转成数组
介绍单页面应用和多页面应用
redux 状态树的管理
介绍 localstorage 的 API

蘑菇街

html 语义化的理解
<b>和<strong>的区别
对闭包的理解
工程中闭包使用场景
介绍 this 和原型
使用原型最大的好处
react 设计思路
为什么虚拟 DOM 比真实 DOM 性能好
react 常见的通信方式
redux 整体的工作流程
redux 和全局对象之间的区别
Redux 数据回溯设计思路
单例、工厂、观察者项目中实际场景
项目中树的使用场景以及了解
工作收获

酷家乐

react 生命周期
react 性能优化
添加原生事件不移除为什么会内存泄露
还有哪些地方会内存泄露
setInterval 需要注意的点
定时器为什么是不精确的
setTimeout(1)和 setTimeout(2)之间的区别
介绍宏任务和微任务
promise 里面和 then 里面执行有什么区别
介绍 pureComponet
介绍 Function Component
React 数据流
props 和 state 的区别
介绍 react context
介绍 class 和 ES5 的类以及区别
介绍箭头函数和普通函数的区别
介绍 defineProperty 方法，什么时候需要用到
for..in 和 object.keys 的区别
介绍闭包，使用场景
使用闭包特权函数的使用场景
get 和 post 有什么区别

百分点

React15/16.x 的区别
重新渲染 render 会做些什么
哪些方法会触发 react 重新渲染
state 和 props 触发更新的生命周期分别有什么区别
setState 是同步还是异步
对无状态组件的理解
介绍 Redux 工作流程
介绍 ES6 的功能
let、const 以及 var 的区别
浅拷贝和深拷贝的区别
介绍箭头函数的 this
介绍 Promise 和 then
介绍快速排序
算法：前 K 个最大的元素

海风教育

对 react 看法，它的优缺点
使用过程中遇到的问题，如何解决的
react 的理念是什么（拿函数式编程来做页面渲染）
JS 是什么范式语言(面向对象还是函数式编程)
koa 原理，为什么要用 koa(express 和 koa 对比)
使用的 koa 中间件
ES6 使用的语法
Promise 和 async/await 和 callback 的区别
Promise 有没有解决异步的问题（promise 链是真正强大的地方）
Promise 和 setTimeout 的区别（Event Loop）
进程和线程的区别（一个 node 实例就是一个进程，node 是单线程，通过事件循环来实现异步
）
介绍下 DFS 深度优先
介绍下观察者模式
观察者模式里面使用的数据结构(不具备顺序 ，是一个 list)

## JavaScript

图片懒加载

实现页面加载进度条

事件委托

实现 extend 函数

为什么会有跨域的问题以及解决方式

jsonp 原理、postMessage 原理

实现拖拽功能，比如把 5 个兄弟节点中的最后一个节点拖拽到节点 1 和节点 2 之间

动画：setTimeout 何时执行，requestAnimationFrame 的优点

手写 parseInt 的实现：要求简单一些，把字符串型的数字转化为真正的数字即可，但不能使用 JS 原生的字符串转数字的 API，比如 Number()

编写分页器组件的时候，为了减少服务端查询次数，点击“下一页”怎样能确保还有数据可以加载（请求数据不会为空）？

ES6 新增了哪些特性，使用过哪些，也有当场看代码说输出结果的

JS 模块化的实践

require.js 的实现原理（如果使用过 webpack，进一步会问，两者打包的异同及优缺点）

promise 的实现原理，进一步会问 async、await 是否使用过

实现 gulp 的功能

使用前端框架（angular/vue/react）带来哪些好处，相对于使用 jQuery

vue 双向数据绑定的实现

单页应用，如何实现其路由功能

## 性能优化

项目中使用过哪些优化方法

输入一个 URL，Enter 之后发生了什么

（承上）页面的渲染过程

优化中会提到缓存的问题，问：静态资源或者接口等如何做缓存优化

页面 DOM 节点太多，会出现什么问题？如何优化？

## 比较重要的知识点

原型链与作用域

闭包

模块化（amd/cmd/umd/ES6 module）

跨域多种方式，如 jsonp

JavaScript 中的 this 指向问题

CORS

AJAX 的几种状态，ajax 与 fetch，hijax

iframe 与 onload 阻塞主页面

前端安全与 CSRF，XSS，SQL 注入，DDOS

JS 异步加载

IE 内存泄露

JS 创建对象的几种方式

JS 继承的几种方式与优缺点

SEO

ES6 新特性

promise 与 generator

服务器推

jQuery 相关

js 捕获与冒泡

drag 和 drop 实现拖拽

cookie/session/本地存储

雅虎网站优化的军规

CSS 与 JS 的阻塞加载

Chrome / IE 浏览器事件兼容

CSS 相关

垂直水平居中

盒模型

浮动与定位

排版引擎与 JS 引擎

GPU 加速与动画性能

DOM1，DOM2，DOM3 规范

CSS 性能

h 标签与 title 标签

em 与百分比等

浏览器缓存与应用缓存

div 与 table 布局

Web 标准

CSS 的 hack 技术

png/jpg/webp 图片格式

canvas 与 svg

CSS3 的新特性，如 flex 布局等

响应式布局

link 与 import 区别

三栏自适应

b 和 strong，i 和 em 区别

减少页面回流

BFC

硬件加速与动画优化

前端自动化相关

webpack 相关

webpack-dev-server 相关

单页面打包工具+多页面打包工具

babel 相关

其他知识

http/1.1 与 http2

http 三次握手协议

http 状态码

JSON 与 XML

前端性能优化

nodejs/npm 相关内容

算法

几种排序算法

回文字符

递归(很重要)

其他常见的前端算法

# 面试准备

[TOC]

一面：考察基础，必须过硬，如：js、css、html、tcp/ip 协议栈、浏览器渲染等。

二面：结合实际项目考察技术深度，如：react、vue、koa、ts、webpack 等。

三面：结合实际项目考察项目思考，如：react 的优缺点、前端方向的思考、以及解决问题的思考方式等。

## 基础原理与编程技巧

### 页面渲染流程

html 加载解析、js 加载解析、css 记载解析、reflow、repaint

### 闭包

有权访问另一个**函数作用域中变量**的函数，常用形式就是在**一个函数内返回另一个函数**。

### this 指向问题

### call 和 apply 区别? 有的还会加问 bind

### 面向对象编程中的继承问题, 原型链问题

### 原型

我们创建的每一个**函数都有一个属性 prototype**，这个属性是**一个指针**，指向一个对象，这个对象的**用途**是包含可以由特定类型的**所有实例**共享的属性和方法。

### 熟悉模块化开发，包的概念，分割的概念

[CommonJS 模块与 ES6 模块的区别](../../blog/11.ECMAScript6Primer/ES6新特性.md)

将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起
块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信

- commonjs
- require

### 前端缓存

[参考 blog 总结](../../blog/3.浏览器原理/浏览器的缓存机制/浏览器缓存.md)

## 框架与库

### 通用问题

#### 封装过哪些组件?有自己写过 UI 组件吗

通用组件封装？

#### 什么是 MVVM , 和 MVC 是什么区别, 原理是什么

### react 相关（看一下详细的问题、再看一波官方文档）

参考 react-learn 的内容，统一整理。

### vue 相关（看一下 vue 的官方文档）

统一整理为 vue-learn 下的。

#### 有 Web App/小程序开发经验，有线上项目

#### 对数据结构和算法设计有充分理解

## 常见经典的问题整理一下，不要被说基础太差，着重在基础原理，基础概念，基础操作，以及 react 相关内容

## 看面试视频，或许讲的更清楚，找师兄讲一下经验

## 基础概念

[每个 JavaScript 工程师都应懂的 33 个概念](https://zhuanlan.zhihu.com/p/65161857?utm_source=wechat_session&utm_medium=social&utm_oi=72254268375040)

### 调用堆栈

调用栈是**解释器**（就像浏览器中的 javascript 解释器）追踪函数执行流的一种机制。当执行环境中调用了多个函数时，通过这种机制，我们能够追踪到哪个函数正在执行，执行的函数体中又调用了哪个函数。

### 基本数据类型

string，number，boolean，null，undefined，symbol

### 值类型和引用类型

值类型： JavaScript 中的值类型的**值是不可变**的：数字、字符串、布尔值、null 和 undefined 等都属于不可变类型。
引用类型： JavaScript 中的**引用类型的值是可变的**。对象，但是对象也是可以设置不可修改的。

### 隐式, 显式, 名义和鸭子类型

隐式： ""+、+、比较计算，==，===，>，<、

显式：parseInt()、parseFloat()、toString()

ECMAScript 中可用的 3 种强制类型转换如下：

- Boolean(value) - 把给定的值转换成 Boolean 型；
- Number(value) - 把给定的值转换成数字（可以是整数或浮点数）；
- String(value) - 把给定的值转换成字符串；

鸭子类型：鸭子类型（duck typing）如果它走起路来像鸭子，叫起来也是鸭子，**那么它就是鸭子**。只关注对象的行为，不关注对象本身面向接口编型 ，而不是面向实现编程，是设计模式中最重要的思想。

### == vs ===, typeof vs instanceof

### this, call, apply 和 bind

[参考文章](https://juejin.im/post/59bfe84351882531b730bac2)

instanceof 运算符用于**测试构造函数的 prototype 属性**是否出现在**对象的原型链**中的任何位置。

#### this

1. 对于一般函数 this 永远指向最后调用它的**那个对象**。

2. 箭头函数的 this **始终指向函数定义时的 this**，而非执行时。

3. 改变 this 的指向我总结有以下几种方法：

- 使用 ES6 的**箭头函数**
  - 箭头函数中**没有 this 绑定**，必须通过**查找作用域链来决定其值**，如果箭头函数被非箭头函数包含，则 this 绑定的是**最近一层非箭头函数的 this**，否则，this 为 undefined
- 在函数内部使用 \_this = this
- 使用 apply、call、bind
- new 实例化一个对象

#### apply、call，这里只是改变了函数执行的上下文环境

```js
fun.apply(thisArg, [argsArray])
fun.call(thisArg, [, arg1[, arg2[, ...]]])
```

apply 和 call 的区别是 call 方法接受的是**若干个参数列表**，而 apply **接收的是一个包含多个参数的数组**。

#### bind

bind()方法**创建一个新的函数**, 当被调用时，将**其 this 关键字设置为提供的值**，在调用新函数时，在任何提供之前提供一个给定的参数序列。

### 函数作用域, 块级作用域和词法作用域

词法作用域，函数的作用域在**函数定义的时候就决定了**。

### 闭包，closure

闭包是函数和声明该函数的词法环境的组合。

定义：有权访问**另一个函数作用域中变量**的函数，常见的形式就是在一个函数内部创建另一个函数

#### 作用域的问题

变量的作用域无非就两种：全局变量和局部变量（函数作用域的变量）。

#### 为什么要用闭包：（闭包的优缺点）

用处有两个

- 一个是前面提到的可以读取函数内部的变量；
- 另一个就是让这些变量的值始终保持在内存中，不会在调用后被自动清除。

#### 用途场景

- 匿名自执行函数
- 结果缓存
- 封装
- 实现类和继承

#### 闭包存在的问题

- 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以**不能滥用闭包**，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。
- 闭包会在父函数外部，改变父函数内部变量的值。

### map, reduce, filter 等高阶函数

#### 高阶函数，Higher-order function

以函数为参数或者返回值的函数，称为高阶函数。

### 变量提升

- JavaScript 中，**函数及变量的声明都将被提升到函数的最顶部**。
- JavaScript 中，变量可以**在使用后声明**，也就是变量可以先使用再声明。
- JavaScript 初始化不会提升，初始化赋值是不会提升的，哪里赋值哪里使用。

### Promise，微任务

- then() 函数会返回一个全新的 Promise，和原来的不同。
- catch() 是 then 的一种特例。

Promise.then(successCallback, failureCallback);

也就是说，如果发生了错误，不处理的情况下，会抛出错误，停止执行，否则就会继续执行。

遇到异常抛出，promise 链就会停下来，**直接调用链式中的 catch 处理程序来继续当前执行**。

### 立即执行函数, 模块化, 命名空间

### 递归

尾调用是函数式编程中一个很重要的概念，当一个函数执行时的**最后一个步骤是返回另一个函数的调用**，这就叫做尾调用。

### 算法

### 数据结构

- 堆（heap），堆是堆内存的简称。
- 栈（stack），栈是栈内存的简称。

说到堆栈，我们讲的就是内存的使用和分配了，没有寄存器的事，也没有硬盘的事。

栈，线性结构，后进先出，便于管理。堆，一个混沌，杂乱无章，方便存储和开辟内存空间。

#### 堆内存

堆是动态分配内存，内存大小不一，也不会自动释放。

- js 中其他类型的数据被称为**引用类型的数据**（如**对象、数组、函数**等），它们是通过拷贝和 new 出来的，这样的数据存储于堆中。
- **引用类型的数据的地址指针是存储于栈中的**，当我们想要访问引用类型的值的时候，需要**先从栈中获得对象的地址指针，然后，在通过地址指针找到堆中的所需要的数据**。

#### 栈内存

栈是自动分配相对固定大小的内存空间，并由系统自动释放。

js 的基本类型就 5 种，Undefined、Null、不是 new 出来的布尔、数字和字符串，它们**都是直接按值存储在栈中的**，每种类型的数据占用的内存空间的大小是确定的，并由系统**自动分配和自动释放**。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。

#### 传值与传址

栈内存中的变量是传值，堆中的引用类型是传址。

#### 浅拷贝和深拷贝

浅拷贝就是对于引用类型只拷贝了指针，地址。

#### 经典的数据结构大概就那么几种

- list
- stack
- queue
- linkedList
- dictionary
- hash
- set，一是集合中的成员是无序的，二是集合中不允许相同成员存在。
- tree，树是非线性，分层存储的数据结构。可用来存储文件系统或者有序列表。
- graph

### 消息队列和事件循环(main)

[参考 BLOG-JavaScript 执行机制.md](../../blog/0.5.JS/BLOG-JavaScript执行机制.md)

### 继承, 多态和代码复用

### 按位操作符, 类数组对象和类型化数组

### DOM 树和渲染过程

### new 与构造函数, instanceof 与实例

### 原型继承与原型链

### Object.create 和 Object.assign

### 工厂函数和类

### 设计模式

- 单例模式
- 中介者模式
- 装饰者模式

### Memoization

memoization 是一种优化技术，主要用于通过存储昂贵的函数调用的结果来加速计算机程序，并在再次发生相同的输入时返回缓存的结果。

### 纯函数, 函数副作用和状态变化

### 耗性能操作和时间复杂度

### JavaScript 引擎

(1) JS 是单线程语言

(2) JS 的 Event Loop 是 JS 的执行机制。深入了解 JS 的执行,就等于深入了解 JS 里的 event loop

### 二进制, 十六进制, 十进制, 科学计数法

### 偏函数, 柯里化, Compose 和 Pipe

所谓**偏函数**，就是固定一个函数的一个或者多个参数，返回一个新的函数，这个函数用于接受剩余的参数。
**柯理化**是把一个有 n 个参数的函数变成 n 个只有 1 个参数的函数。

compose 函数的作用就是**组合函数**的，将函数串联起来执行。

### 代码整洁之道

## 整理建立，修改，投一些可能会去的大公司

## 自我介绍，项目介绍

### 比较好的项目，具体的细节

### 在次看一下，从 url 到网页显示的流程，该怎么简洁的回答

## Vue 和 React 的优点分别是什么

## React

在以下情况下使用 refs：

- 与第三方 DOM 库集成
- 触发命令式动画
- 管理焦点，文本选择或媒体播放

```js
this.textInput = React.createRef();
<input type="text" ref={this.textInput} />;
```

### 熟悉 Vue+nuxt+express 开发框架，有实际项目经验，能够深入剖析框架部分及实现原理

### 有至少两年以上前端开发经验，有前端架构设计经验；（怎么证明有架构设计能力）

### 搜集一下可能出现的 gitflow 的问题，然后整理成册，着重看一下官方文档

## 编程技能提升

### 什么是错误优先的回调函数

错误优先(**Error-first**)的回调函数（**Error-First Callback**）用于同时返回错误和数据，其中第一个参数返回错误，并且验证它是否出错，其他参数返回数据。

```js
fs.readFile(filePath, function(err, data) {
  if (err) {
    // 处理错误
    return console.log(err);
  }
  console.log(data);
});
```

## Node 相关

### nodejs 在 80 端口上的监听权限问题

[使用端口转发解决 nodejs 在 80 端口上的监听权限问题](https://blog.csdn.net/newborn2012/article/details/23860687)

#### 原因

由于 linux 的系统限制，**普通用户是无法打开 1024 以下端口的**，这里面就包括 http 的默认端口 80。

#### 实现方式

- 这就使得很多用户使用**root 权限**来执行 node，这带来了不可预计的安全问题，所以这并不是一个好办法。
- 使用 iptables 的端口转发功能来解决这个问题
  - 首先将 node 的主程序绑定到高于 1024 端口，比如 8090
  - 配置 iptables 将 80 端口转发到 8090 上。

## 前端优化

### 前端可以做哪些优化, 或问你 SEO, 基本都问

## 项目

问你用过什么技术, 用过哪些插件解决什么问题之类的, 了解一下你的技术栈.

那些开发用的插件和技术名词最好回想, 整理一下, 不要面试的时候蒙了.

- 负责什么模块?
- 使用到的技术?
- 遇到过什么难题?
- 怎么解决的?

工作之外的学习情况? 一般会从侧面了解一下

## 开发流程

一个版本从需求讨论, 一直到开发完成上线, 大致经过以下几个过程.

- 需求讨论(技术可行性, 时间需求等)
- 需求讲解(产品告诉技术我们这次需要多什么)
- 前后端约定接口形式(一般都有通用形式的要求, 但具体参数和返回值需要具体商议)
- 前端, 后端, 客户端分别开发
- 前后端联调(测试交互功能)
- 提测(交于 QA 测试功能)
- QA 测试(禅道等 bug 管理平台, bug 指向人修改 bug)
- 预上线(模拟真实线上环境)
- 上线(预上线一切正常就可以上线了)

## 手写函数列表

### promise

### 深 copy

### 浏览器缓存的一些问题

- memory cache
- disk cache
- 协商缓存
- cache-control
- expires
- etag
- no-cache
- no-store
- html 后边添加时间戳的意义

### 从输入 url 到页面加载完成的过程都发生了什么

## 找自身的亮点

- 会 Vue 的比会 React 的多，全家桶做 SPA 都会，**服务端渲染**基本没接触过。
- 项目做过不少，但**技术含量普遍不高**，体现不出什么。
- Webpack 用过但不会配置，Git 会基本操作但不懂 **Git Workflow**。
- ESLint 之类的基本都听过，**坚持做的没几个**。
- 英语水平**普遍很糟糕**。

### [闪光点](https://www.zhihu.com/question/301802742/answer/528863253)

- 知识面广且某几个方向达到一定深度。
- 项目/工作经历中最重要的是自己拿到了什么样的结果，而不是实现了什么样的功能。
- 需要一定的执行力与推动力。

### 面试中发现的一些共性问题

1、因一些基础算法、数据结构、设计模式理论不扎实导致一些编程思维难于理解。
2、计算机体系结构、操作系统理论、网络理论不扎实导致到后期一些东西难于理解，往全栈方向扩展比较困难。比如 node 开发 ，在 I/O ,进程、线程、IPC 、线程锁方面有些概念就比较难于理解，而导致不能很好得使用 node 的 api 。
3、前端整体体系架构没有做过深入思考，导致用会用，但不知道为什么用，用另外一个有什么区别。
4、重复低水平工作，工作业务驱动。
5、**工作环境中无高手**，前端开发团队大家水平相当，没有高手能够指导自己进入下一个层次。
6、**有意识但是没有行动**，我的网盘收集了一堆资料或者一堆视频，然后就没有然后了 。

- 调用堆栈
- 作用域闭包
- this 全面解析
- 深浅拷贝原理
- 原型 Prototype
- 高阶函数
- 事件机制
- Event Loop 原理
- Promise 原理
- Async/Await 原理
- 防抖/节流原理
- 模块化详解
- ES6 重难点
- 计算机网络概述
- 浏览器渲染原理
- webpack 配置
- webpack 原理
- 前端监控
- 跨域和安全
- 性能优化
- VirtualDom 原理
- Diff 算法
- MVVM 双向绑定
- Vuex 原理
- Redux 原理
- 路由原理
- VueRouter 源码解析
- ReactRouter 源码解析

### 写一个深度克隆函数，参数类型包括所有

## 算法问题

### 用 js 实现冒泡排序

## 具体场景实现方式

### 实现图片轮播的大致思路，然后问了图片是 100 张，10000 张的时候的注意点

## http 协议

http 协议，两分钟之内讲一讲

链表与队列的区别，（直接说了这个应该很简单吧）
