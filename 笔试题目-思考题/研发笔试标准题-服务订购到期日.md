# 服务订购到期日

在真实的业务场景中，客户可以在任意一天订购我们的服务，订购周期可以是一个月、一个季度、半年或一年，在订购日后的这么多月后的凌晨 0 点订单到期。

以下举例说明订购的过期计算方式：

- 在 2016-11-10 订购一个月，订购将在 2016-12-10 过期
- 在 2016-12-10 订购一个月，订购将在 2017-01-10 过期
- 在 2017-01-30 订购一个月，订购将在 2017-02-28 过期
- 在 2017-05-31 订购三个月，订购将在 2017-08-31 过期

## 问题 1（无需编程）

假定我们每天可以收到 4 个订单，其中一个是一个月周期的，一个是一个季度周期的，一个是半年周期的，一个是一年周期的。这样的订单从很久以前，比如五年前就开始了。

请通过分析回答：在哪一天到期的订单会最多，有多少个？具体是哪几个订单？

并对分析过程进行解释。

### 问题 1（无需编程）ans

- 由于订购周期是按月为基础单位，一个季度也就是三个月，以此类推；
- 按月计算，每月的天数是不同的，所以问题转化为每月天数对截止日期影响的问题；
- 如果订购一个月，可以直接理解为在当前月份添加 1，如果年份改变就在年份上边添加 1，如果这个月份没有对应的天数，就取最后的日期，比如 1 月的 31，2 月的 28 或者 29，4 月的 30。
- 所以在每天都是同样的订单数量情况下，直观的感受会是某一年的 2 月 28 日最多。

每天都收到 4 单，接受到的订单是连续的。**如果每月的天数都是一致的**，那么，按照 5 年期计算：

- 开始的第 1 个月每天到期的订单都是 0；
- 2-3 月是 1（前一个月份订单）；
- 4-6 月是 2（前一个月份订单、前一个季度订单）；
- 7-12 月是 3（前一个月份订单、前一个季度订单，前一个半年度订单）；
- 13-61 月是 4（前一个月份订单、前一个季度订单，前一个半年度订单，前一年度订单）；
- 62-63 月是 3（前一个季度订单，前一个半年度订单，前一年度订单）；
- 64-66 月是 2（前一个半年度订单，前一年度订单）；
- 67-72 月是 1（前一年度订单）；

如果每个月的天数不同，那么，前一个月天数多与当前月的天数的最后一天，会到期更多的订单，结合闰年的差别，应该是闰年之后的一年的 2 月 28 日到期的订单是最多的。从五年前开始，也就是 **2017 年 2 月 28 日**。

具体的订单为：

- 2016 年 2 月 28、29 日单；（一整年到期订单）
- 2016 年 8 月 28、29、30、31 日单；（半年到期订单）
- 2016 年 11 月 28、29、30 日单；（季度到期订单）
- 2017 年 1 月 28、29、30、31 日单；（月份到期订单）

总共为**13 单**。

## 问题 2

请实现一个方法，给定订购的年月日（year, month, day)，已知订购时长是一个月，返回订单的到期日。year, month, day 均为整数，保证是正确的日期。

- 在考虑我们的喜好（Python == Javascript > Java > C/C++）的基础上，选择你最擅长的语言，给出**「可在生产环境中放心使用」**级别的代码。

  - Python 请实现以下方法：

    - ```python
      def getExpirationDate(year, month, day):
          # TODO
          return [year, month, day]
      ```

  - Javascript 请实现以下方法：

    - ```javascript
      function getExpirationDate(year, month, day) {
        // TODO
        return [year, month, day];
      }
      ```

  - 其余语言请参考上述语言入参和返回值进行实现。

- 主体代码避免使用日期相关的系统库/第三方库。

  - Python 应避免使用 `datetime` 及同类库。
  - Javascript 应避免使用 `Date` 对象。

- 测试代码部分无限制。需要包括至少 3 个测试数据。

- 简要解释解决思考过程和代码实现思路。

### 问题 2， ans

#### 实现代码如下

```js
function getExpirationDate(year, month, day) {
  let flag = isLeapYear(year),
    monthDay,
    realDay;
  monthDay = [31, flag ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  month = ~~month + 1;
  if (month > 12) {
    year += 1;
    month = 1;
  }
  realDay = monthDay[month - 1];
  day = day > realDay ? realDay : day;
  return [year, month, day];
}
function isLeapYear(year) {
  year = ~~year;
  return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}
```

#### 思考过程与代码实现思路

- 首先判断最终的日期肯定要与是否闰年有关，实现方法`isLeapYear`；
- 建立当前年份对应的每月的天数的数组`monthDay`；
- 由于是只增加一个月，所以直接对 month 取整，然后加 1，由于每次只能加 1，所以只要超过 12，就修改 year 加 1，month 等于 1，表示跨了一年；
- 通过要还的月份取得对应月份的天数`realDay`，然后判断是否大于订够的日期天数，二者取其小；

简单测试代码：

```js
// 一个月之后到期，主要考虑2月29的问题
getExpirationDate(2016, 12, 12);
getExpirationDate(2018, 6, 11);
getExpirationDate(2019, 5, 23);
```

测试五年来的数据：

```js
// 查看五年内的次数问题
let resMap = {},
  months = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
  year,
  flag,
  monthDay,
  res;

new Array(5).fill(2014).forEach((item, index) => {
  year = item + index;
  flag = isLeapYear(year);
  monthDay = [31, flag ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

  months.forEach((month, _index) => {
    new Array(monthDay[_index]).fill(" ").forEach((__item, day) => {
      console.log(`当前的日期是：${year}年${month}月${day + 1}日`);
      res = getExpirationDate(year, month, day + 1);
      resMap[res] = ~~resMap[res] + 1;
      console.log(`到期的日期是：${res}`);
    });
  });
});
// console.log("resMap: ", resMap);
```
