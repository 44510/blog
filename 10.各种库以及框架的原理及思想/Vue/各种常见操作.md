
# Vue常见的操作

## 1. 事件处理相关v-on
官网说明地址：https://vuefe.cn/v2/api/#v-on

添加事件 v-on:click简写： v-on = @

回调函数选项写在methods（选项，是一个对象）下边

#### 回调函数：
1. 在子组件的methods内定义；
2. 或者由父组件传递过来的，这样就可以把子组件的参数改变传递给父组件，类似于mobx的操作。
3. 内联写法，直接调用组件的参数来操作（参数都定义在data内）；


用在普通元素上时，只能监听 原生 DOM 事件。

用在**自定义元素组件**上时，也可以监听子组件触发的自定义事件。

### 事件处理
官网说明地址：https://vuefe.cn/v2/guide/events.html
传递当前的dom节点到事件处理函数中，在对应参数位置**添加$event参数**；

```
<!-- 内联语句 -->
<my-component @my-event="handleThis(123, $event)"></my-component>
这里括号中的参数就相当于react中的.bind(this, arg1, arg2);
```




#### 修饰符的使用（一些常用事件操作都可以使用修饰符来替代）

https://vuefe.cn/v2/guide/events.html#事件修饰符-Event-Modifiers

- 事件修饰器
- 按键修饰器
- 系统辅助按键


使用修饰符时的顺序会产生一些影响。

注意区分dom事件与组件事件（自定义事件）


#### 使用 v-on 有几个好处：
1. 通过浏览 HTML 模板，就能很方便地找到在 JavaScript 代码里对应的处理函数。
2. 由于无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，并且和 DOM 完全解耦，更易于测试。
3. 当一个 ViewModel 被销毁时，所有的事件监听器都会被自动删除。你无须担心如何自己清理它们。


#### 模拟触发事件

**方式一（分发实践，通过别的函数来触发）**

```
<a class="link" @click.native="test">333</a>
methods: {
	test: function () {
		console.log(1);
		this.$emit('test');//把a标签的点击事件分发
	},
	shout:function () {
		console.log('我触发了它');
	}
}
```

在组件中，可以使用 `$emit`, `$on`, `$off` 分别来分发、监听、取消监听事件。

**`$emit`, `$on`, `$off`**

官方文档介绍： https://vuefe.cn/v2/api/#实例方法-事件

**方式二（与原生dom操作类似，明显更低级一点）**

```
methods:  {
    handleBtnClick: function(){
        document.getElementById("text").click();
    },
    handleTextClick: function(){
        alert("hello");
    }
}
```

## 2. 子组件调用父组件的方法

**涉及到组件之间的通信的问题。组件之间的通信可以分为以下几种：**

1. 父子组件传递，父向子传递采用props；

   ```
   //parent.vue
   <parent>
     <child :foo="foo"><child>
   </parent>
   //child.vue
   <button @click="foo">调用<button>
   ```

   也就是说 props 用来传数据，子组件调用父组件方法使用事件，网络请求等比较大的事情走 vuex，小事情还是通过 props 和 emit 等操作来进行处理。

   **props是用来传输数据的，而且是单向数据流，所以我觉得不能用来向父组件调用方法。**
   vuex这个我不是很了解，但是在我们的项目中主要是用来管理一些全局的变量或者事件，我觉得父子组件之间的通信就来用到全局事件，有点大材小用了。
   在上面给出的例子中，可以看见在子组件中使用$emit来触发父组件中绑定的事件。

   1. 用`$emit`向父组件触发一个事件，父组件监听这个事件就行了。
   2. **直接用`this.$parent.xxxx`这样直接调用父组件的方法。不需要通过props（属性传递）来传递。**
      $parent, 父实例

2. 子向父采用事件emit。

   ```
   <template id="">
       <Child @refreshList="onRefresList"></Child>
   </template>

   <script>
       export default {
           data () {
               return {
                   
               };
           },
           components: {
               Child
           },
           mounted() {},
           methods: {
               onRefresList () {
                   
               }
           },
           computed: {},
           watch: {}
       };
   </script>

   Child.vue
   this.$emit('refreshList');
   ```

   ​

3. 非父子组件的传递，全局Event bus，new一个vue的实例，采用事件的方式通信，**再者采用vuex全局状态管理**。




## 3. 组件自身的参数都定义在data内

#### 对比于react中的state？还是相当于constructor中定义的属性值。





## 4. 组件的props属性
官方说明文档： https://vuefe.cn/v2/guide/components.html#Props

每个组件实例都有自己的**孤立隔离作用域**。也就是说，不能（也不应该）直接在子组件模板中引用父组件数据。

**要想在子组件模板中引用父组件数据，可以使用 props 将数据向下传递到子组件。**

属性传递的时候，在父组件内的属性需要使用中划线来连接（**HTML 属性会忽略大小写(case-insensitive)**），子组件使用的时候要对应的转为驼峰式。

```
Vue.component('child', {
  // camelCase in JavaScript
  props: ['myMessage'],
  template: '<span>{{ myMessage }}</span>'
})
<!-- HTML 中的串联式命名 -->
<child my-message="hello!"></child>
```

### 动态props

使用 `v-bind` 将 props 属性动态地绑定到父组件中的数据。无论父组件何时更新数据，都可以将数据向下流入到子组件中。

```
<div>
  <input v-model="parentMsg">
  <br>
  <child v-bind:my-message="parentMsg"></child>
</div>
还可以使用 v-bind 简写语法，通常看起来更简洁：
<child :my-message="parentMsg"></child>
```

如果你想要将一个对象中的所有属性都作为 props 传递，可以使用不带参数的 `v-bind`（将 `v-bind:prop-name` 替换为 `v-bind`）。

```
<todo-item v-bind="todo"></todo-item>
等同如下：
<todo-item
  v-bind:text="todo.text"
  v-bind:is-complete="todo.isComplete"
></todo-item>
```

#### 字面量传值 vs. 动态传值(Literal vs. Dynamic)

```
<!-- 这会向下传递一个普通字符串 "1" -->
<comp some-prop="1"></comp>

<!-- 这会向下传递一个真正的数值 -->
<comp v-bind:some-prop="1"></comp>
```

### 单向数据流(One-Way Data Flow)

官方文档位置： https://vuefe.cn/v2/guide/components.html#单向数据流-One-Way-Data-Flow

所有的 props 都是在子组件属性和父组件属性之间绑定的，按照**自上而下单向流动**方式构成：**当父组件属性更新，数据就会向下流动到子组件，但是反过来却并非如此。**

这种机制可以防止子组件意外地修改了父组件的状态**，会造成应用程序的数据流动变得难于理解**。

**每次父组件更新时，子组件中所有的 props 都会更新为最新值。**

在 JavaScript 中对象和数组会作为**引用类型传入**，因此，如果 prop 是一个对象或数组，在子组件内部修改对象或数组自身，**将会影响**父组件的状态。





## 5. 计算属性computed





## 6. 表单输入绑定

你可以用 `v-model` 指令在表单 `<input>` 及 `<textarea>` 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。





## 7. 创建数据双向绑定



 ```
// 表单输入
<input v-model="message" placeholder="edit me">
// 标签显示
<p>Message is: {{ message }}</p>
// 组件的状态声明
data() {
    return {
        message: 'defaultValue'
    }
}
 ```





## 8. 生命周期

#### beforeCreate（应该是在react组件的componentWillMount这个阶段，或者就相当于constructor）

在**实例初始化之后**，立即**同步调用**，在数据观察(data observer)和 event/watcher 配置之前被调用。（这个时候应该参数也没拿到）

#### created（js对象已生成，绑定dom节点的事还没做，这个时候可以用来请求数据，修改初始值）

实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，`$el` 属性目前不可见。

#### beforeMount

在挂载开始之前被调用：**相关的 `render` 函数首次被调用**。

**该钩子在服务器端渲染期间不被调用。**

#### mounted（应该相当于react组件的componentDidMount阶段，这个时候应该可以进行el操作）

在实例挂载之后调用，其中 `el` 被新创建的 `vm.$el` 替代。如果 root 实例挂载了一个文档内元素，当 `mounted` 被调用时 `vm.$el` 也在文档内。

**该钩子在服务器端渲染期间不被调用。**

#### beforeUpdate

在 DOM 被 patch 之前调用数据修改。这是在 DOM 更新之前，访问已有 DOM 的最佳时机，例如，手动地移除之前添加的事件监听器。

**在服务器端渲染期间不会调用这个钩子函数，因为在服务器端只执行初始渲染。**

#### updated

