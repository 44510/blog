---
title: css选择器，伪类，伪元素
date: 2017-3-03
tags:
  - CSS
  - CSS选择器
categories:
  - [CSS, CSS选择器]
---

## CSS 选择器有哪些

大的分类：

- !important 最高 1000000000000
- 行内样式 1000
- id 100
- class 类、伪类 10
- 属性 10
- 元素、伪元素 1
- 通配选择器\*对特殊性没有贡献 0

id、class、tag、伪类()、伪元素、属性选择、通配符、兄弟选择器、相邻选择器

1. **\* 通用选择器**：选择所有元素，**不参与计算优先级**，兼容性 IE6+
2. **#X id 选择器**：选择 id 值为 X 的元素，兼容性：IE6+
3. **.X 类选择器**： 选择 class 包含 X 的元素，兼容性：IE6+
4. **X Y 后代选择器**： 选择满足 X 选择器的后代节点中满足 Y 选择器的元素，兼容性：IE6+
5. **X 元素选择器**： 选择标所有签为 X 的元素，兼容性：IE6+
6. **:link，：visited，：focus，：hover，：active 链接状态**： **选择特定状态**的链接元素，顺序 LoVe HAte，兼容性: IE4+
7. **X + Y 直接兄弟选择器**：在**X 之后第一个兄弟节点**中选择满足 Y 选择器的元素，兼容性： IE7+
8. **X > Y 子选择器**： 选择 X 的子元素中满足 Y 选择器的元素，兼容性： IE7+
9. **X ~ Y 兄弟**： 选择**X 之后所有兄弟节点**中满足 Y 选择器的元素，兼容性： IE7+
10. **[attr]**：选择所有设置了 attr **属性**的元素，兼容性 IE7+
11. **[attr=value]**：选择属性值刚好为 value 的元素
12. **[attr~=value]**：选择属性值为空白符分隔，其中一个的值刚好是 value 的元素
13. **[attr|=value]**：选择属性值刚好为 value 或者 value-开头的元素
14. **[attr^=value]**：选择属性值以 value 开头的元素
15. **[attr$=value]**：选择属性值以 value 结尾的元素
16. **[attr*=value]**：选择属性值中包含 value 的元素
17. **[:checked]**：**选择单选框，复选框**，下拉框中选中状态下的元素，兼容性：IE9+
18. **X:after, X::after**：**after 伪元素**，选择元素虚拟子元素（元素的最后一个子元素），CSS3 中::表示伪元素。兼容性:after 为 IE8+，::after 为 IE9+
19. **:hover**：鼠标移入状态的元素，兼容性 a 标签 IE4+， 所有元素 IE7+
20. **:not(selector)**：选择**不符合 selector 的元素**。**不参与计算优先级**，兼容性：IE9+
21. **::first-letter**：**伪元素**，选择块元素第一行的第一个字母，兼容性 IE5.5+
22. **:nth-child(an + b)**：**伪类**，选择前面有 an + b - 1 个兄弟节点的元素，其中 n
    &gt;= 0， 兼容性 IE9+
23. **:nth-last-child(an + b)**：伪类，选择后面有 an + b - 1 个兄弟节点的元素
    其中 n &gt;= 0，兼容性 IE9+
24. **X:nth-of-type(an+b)**：伪类，X 为选择器，**解析得到元素标签**，选择**前面**有 an + b - 1 个**相同标签**兄弟节点的元素。兼容性 IE9+
25. **X:nth-last-of-type(an+b)**：伪类，X 为选择器，解析得到元素标签，选择**后面**有 an+b-1 个相同**标签**兄弟节点的元素。兼容性 IE9+
26. **X:first-child**：伪类，选择满足 X 选择器的元素，且这个元素是其父节点的第一个子元素。兼容性 IE7+
27. **X:last-child**：伪类，选择满足 X 选择器的元素，且这个元素是其父节点的最后一个子元素。兼容性 IE9+
28. **X:only-child**：伪类，选择满足 X 选择器的元素，且这个元素是其父元素的唯一子元素。兼容性 IE9+
29. **X:only-of-type**：伪类，选择 X 选择的元素，**解析得到元素标签**，如果该元素没有相同类型的兄弟节点时选中它。兼容性 IE9+
30. **X:first-of-type**：伪类，选择 X 选择的元素，**解析得到元素标签**，如果该元素是此此类型元素的第一个兄弟。选中它。兼容性 IE9+
31. **::first-line**：伪元素，选择块元素的第一行，兼容性 IE5.5+

### 相邻兄弟选择器（这里的兄弟可以理解为其后，相邻就是紧接着的）

`前方兄弟元素 + 紧跟着的目标元素 { 样式声明 }`

- 注意这里的前方兄弟元素，不是后方元素，这样使用 `input:checked+label` 的时候就**要把 input 放在前，label 放在后**。
- 只会返回一个目标元素。

### 通用兄弟选择器（这里的兄弟可以理解为其后，通用就是所有的）

`前方兄弟元素 ~ 目标元素{ 样式声明 }`

其后的元素具有相同的父元素的集合。

```css
.one + li {
  /* 这里匹配到 .two */
}
.one ~ li {
  /* 这里匹配到 .two 和 .three */
}
.two ~ li {
  /* 这里匹配到 .three */
}
```

```html
<ul>
  <li class="one">One</li>
  <li class="two">Two</li>
  <li class="three">Three</li>
</ul>
```

### css 定义的权重

```css
/* 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下/// 例子是演示各种定义的权重值： */

/*权重为1*/
div {
}
/*权重为10*/
.class1 {
}
/*权重为100*/
#id1 {
}
/*权重为100+1=101*/
#id1 div {
}
/*权重为10+1=11*/
.class1 div {
}
/*权重为10+10+1=21*/
.class1 .class2 div {
}

/* 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现 */
```

### 比较流程

1. 优先选取 `!important` 的规则
2. 比较规则的权重（特殊值，下面提到）
3. 后声明的规则优先使用

#### 权重（特殊值）

- 选择器的规则使用 4 个数字来表示，初始值 0,0,0,0
- 行内样式 (style) 的特殊性值，加 1,0,0,0
- ID 选择器的特殊性值，加 0,1,0,0。
- 类选择器、属性选择器或伪类，加 0,0,1,0。
- 元素和伪元素，加 0,0,0,1。
- 通配选择器\*对特殊性没有贡献，即 0,0,0,0。

#### CSS 如何计算选择器优先

- 相同权重，**定义最近者为准**：行内样式 > 内部样式 > 外部样式
- 含外部载入样式时，后载入样式覆盖其前面的载入的样式和内部样式
- 选择器优先级: **行内样式[1000]** > id[100] > class[10] > Tag[1]
- 在同一组属性设置中，**!important 优先级最高**，高于行内样式

## 浏览器是怎样解析 CSS 选择器的

CSS 选择器的解析是**从右向左解析的**。

若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。

若从右向左匹配，**先找到所有的最右节点**，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。

两种匹配规则的性能差别很大，是因为**从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点）**，而从左向右的匹配规则的性能都浪费在了失败的查找上面。

而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。

在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。
