---
title: 打家劫舍
date: 2020-2-27
tags:
  - 数据结构与算法
  - 动态规划
categories:
  - [算法, 动态规划]
---

[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

## 问题分析

动态规划

动态转移方程 `dp[n] = MAX( dp[n-1], dp[n-2] + num )`

1. 由于不可以在相邻的房屋闯入，所以**在当前位置 n 房屋可盗窃的最大值**，
   1. 要么就是 **n-1 房屋**可盗窃的最大值，
   2. 要么就是 **n-2 房屋**可盗窃的最大值加上当前房屋的值，
   3. 二者之间取最大值。
2. 举例来说：
   1. 1 号房间可盗窃最大值为 3， 即为 dp[1]=3，
   2. 2 号房间可盗窃最大值为 4， 即为 dp[2]=4，
   3. 3 号房间自身的值为 2 即为 num=2，
   4. 那么 dp[3] = MAX( dp[2], dp[1] + num ) = MAX(4, 3+2) = 5，3 号房间可盗窃最大值为 55

时间复杂度：O(n)，n 为数组长度。

## js 代码实现

```js
var rob = function (nums) {
  var len = nums.length;
  if (len == 0) return 0;
  var dp = new Array(len + 1);
  // 初始化参数
  dp[0] = 0;
  dp[1] = nums[0];
  // 逐个遍历房间，找到最大值，依次迭代
  // 依次计算在每个房间的最大值
  for (var i = 2; i <= len; i++) {
    // dp[2] = Math.max(dp[1], dp[0] + nums[1])
    dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);
    console.log('dp[i]', i, dp[i - 1], dp[i - 2] + nums[i - 1], dp[i]);
  }
  return dp[len];
};

// test

rob([1, 2, 3, 1]); // 4
// dp[i] 2 1 2 2
// dp[i] 3 2 4 4
// dp[i] 4 4 3 4

rob([2, 7, 9, 3, 1]); // 12
// dp[i] 2 2 7 7
// dp[i] 3 7 11 11
// dp[i] 4 11 10 11
// dp[i] 5 11 12 12
```
