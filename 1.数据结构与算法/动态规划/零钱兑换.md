---
title: 零钱兑换
date: 2020-2-27
tags:
  - 数据结构与算法
  - 动态规划
  - 零钱兑换
categories:
  - [算法, 零钱兑换]
---

## 问题描述

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回  -1。

## 问题分析

1. 动态规划-自上而下
   1. 尽量使用大面值的，后使用小面值的替代
2. 动态规划-自下而上
   1. 先使用小面值的，后使用大面值的替代

[动态规划](https://leetcode-cn.com/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/)

dp，记录在不同组合下的最有最少次数。

推导出「状态转移方程」：`dp[i] = Math.min(dp[i - coin[0]] + 1, dp[i - coin[1]] + 1, ...)`
如：`dp[120] = Math.min(dp[119] + 1, dp[118] + 1, dp[115] + 1);`
简化后：`dp[i] = Math.min(dp[i], dp[i - coin] + 1)`

## js 代码实现

```js
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */

var coinChange = function (coins, amount) {
  let dp = new Array(amount + 1).fill(Infinity);
  dp[0] = 0;

  for (let i = 1; i <= amount; i++) {
    for (let coin of coins) {
      if (i - coin >= 0) {
        // 简化的动态转移方程
        // 不用新的coin与用一个新的icon
        dp[i] = Math.min(dp[i], dp[i - coin] + 1);
      }
    }
  }

  return dp[amount] === Infinity ? -1 : dp[amount];
};
```
