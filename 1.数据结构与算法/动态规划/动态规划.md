---
title: 动态规划
date: 2020-2-27
tags:
  - 数据结构与算法
  - 动态规划
categories:
  - [数据结构与算法, 动态规划]
---

[什么是动态规划（Dynamic Programming）？动态规划的意义是什么？](https://www.zhihu.com/question/23995189/answer/613096905)

[一文读懂动态规划算法](https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650561551&idx=2&sn=6c7421e3b752e8d0b4c266dfe1f81a3a&chksm=f1feea8cc689639aaa123c109efc82442aa5e99269ff604cdfb37f9fccb2d49b2431fc4e4ef3&mpshare=1&scene=23&srcid=1111K6YhQbjwU8x2H1X6nrZn#rd)

[动态规划问题总结](https://leetcode-cn.com/problems/coin-lcci/solution/bei-bao-jiu-jiang-ge-ren-yi-jian-da-jia-fen-xiang-/)

动态规划（Dynamic Programming）

## 问题的场景

先来看看生活中经常遇到的事吧——假设您是个土豪，身上带了足够的 1、5、10、20、50、100 元面值的钞票。现在您的目标是**凑出某个金额 w**，需要用到尽量少的钞票。

依据生活经验，我们显然可以采取这样的策略：能用 100 的就尽量用 100 的，否则尽量用 50 的……依次类推。在这种策略下，666=6×100+1×50+1×10+1×5+1×1，共使用了 10 张钞票。

## “贪心算法”

假设我们面对的局面是“需要凑出 w”，**贪心策略会尽快让 w 变得更小**。能让 w 少 100 就尽量让它少 100，这样我们接下来面对的局面就是凑出 w-100。**长期的生活经验表明，贪心策略是正确的**。

## DP（动态规划，dynamic programming）

将一个问题**拆成几个子问题，分别求解这些子问题**，即可推断出大问题的解。

### 动态规划过程是

**每次决策依赖于当前状态**，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种**多阶段 最优化决策 解决问题的过程**就称为动态规划。

### 基本思想与策略

基本思想与**分治法类似**，**也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息**。

在求解任一子问题时，列出各种可能的局部解，**通过决策保留那些有可能达到最优的局部解，丢弃其他局部解**。依次解决各子问题，最后一个子问题就是初始问题的解。

由于动态规划解决的问题**多数有重叠子问题这个特点**，为减少重复计算，对每一个子问题只解一次，**将其不同阶段的不同状态保存在一个二维数组中**。

**与分治法最大的差别是：**适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。

### 适用的情况

能采用动态规划求解的问题的一般要具有 3 个性质：

（1）最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。

（2） 无后效性：**即某阶段状态一旦确定，就不受这个状态以后决策的影响。**也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。

（3）有重叠子问题：**即子问题之间是不独立的**，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）

```js
// f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}

// 动态规划算法基本框架
for(j=1; j<=m; j=j+1) // 第一个阶段
   xn[j] = 初始值;

for(i=n-1; i>=1; i=i-1)// 其他n-1个阶段
   for(j=1; j>=f(i); j=j+1)// f(i)与i有关的表达式
     xi[j]=j=max（或min）{g(xi-1[j1:j2]), ......, g(xi-1[jk:jk+1])};

t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案

print(x1[j1]);

for(i=2; i<=n-1; i=i+1）
{
     t = t-xi-1[ji];

     for(j=1; j>=f(i); j=j+1)
        if(t=xi[ji])
             break;
}
```
