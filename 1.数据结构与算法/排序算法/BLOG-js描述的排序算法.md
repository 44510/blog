---
title: BLOG-js描述的排序算法
date: 2018-6-6
tags:
  - 算法
---

## 主要的排序算法原理

- 冒泡排序：遍历每个元素，与其后的**元素交换位置**，直到有序，每次排序之后，最大的都会到队尾。
  - 冒泡排序的时间复杂度： O(n^2)
  - 冒泡排序的空间复杂度： O(1)
- 插入排序：对于未排序数据，在已排序序列中**从后向前扫描，找到相应位置并插入。**
  - 平均来说插入排序算法的时间复杂度为：O(n^2）
  - 插入排序空间复杂度为：O(1)
- 选择排序：选择剩余部分的最大或者最小值，放到有序的部分的前面或者后面
  - 时间复杂度：稳定为 O(n^2)
  - 空间复杂度：每次比较一位，空间复杂度 O(1)
- 快速排序：分治法（Divide and conquer）策略来把一个串行（list），选取中间值
  - 时间复杂度：O(nlogn)，最差 n^2
  - 空间复杂度：logn(因为递归调用了)；
- 希尔排序：也称**递减增量排序算法**，是插入排序的一种更高效的改进版本，
  - 时间复杂度： 很不稳定，O(n^1.25)；
  - 空间复杂度： O(1);

## 排序算法的时间与空间复杂度的比较

**算法分析的目的在于选择合适算法和改进算法。**

计算机科学中，**算法的时间复杂度是一个函数**，**它定量描述了该算法的运行时间**。这是一个关于代表算法**输入值**的字符串的长度的函数。

![排序算法的时间与空间复杂度](./imgs/排序算法的时间与空间复杂度.png)

**n**: 数据规模
**k**:“桶”的个数
**In-place**: 占用常数内存，不占用额外内存
**Out-place**: 占用额外内存
**稳定性**：排序后 2 个相等键值的顺序和排序之前它们的顺序相同

### 时间复杂度(Time Complexity)

一个算法的优劣主要**从算法的执行时间和所需要占用的存储空间**两个方面衡量。**在循环调用中为循环的次数乘积**。

同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。

时间复杂度常用**大 O 符号表述**，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，它考察当输入值大小趋近无穷时的情况。

| **排序方法**       | **平均时间** | **最好时间** | **最坏时间** |
| ------------------ | ------------ | ------------ | ------------ |
| 桶排序(不稳定)     | O(n)         | O(n)         | O(n)         |
| 基数排序(稳定)     | O(n)         | O(n)         | O(n)         |
| 归并排序(稳定)     | O(nlogn)     | O(nlogn)     | O(nlogn)     |
| 快速排序(不稳定)   | O(nlogn)     | O(nlogn)     | O(n^2)       |
| 堆排序(不稳定)     | O(nlogn)     | O(nlogn)     | O(nlogn)     |
| 希尔排序(不稳定)   | O(n^1.25)    |              |              |
| 冒泡排序(稳定)     | O(n^2)       | O(n)         | O(n^2)       |
| 选择排序(不稳定)   | O(n^2)       | O(n^2)       | O(n^2)       |
| 直接插入排序(稳定) | O(n^2)       | O(n)         | O(n^2)       |

#### 说明

O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)

一般时间复杂度到了 **2^n(指数阶)及更大的时间复杂度,这样的算法我们基本上不会用了**,太不实用了。比如递归实现的汉诺塔问题算法就是 O(2^n)。

**平方阶(n^2)的算法是勉强能用**,而 nlogn 及更小的时间复杂度算法那就是非常高效的算法了啊。

### 空间复杂度(Space Complexity)

是对一个算法在运行过程中临时**占用存储空间大小的量度**，记做 S(n)=O(f(n))。递归的空间复杂度为 n。

比如直接插入排序的时间复杂度是 O(n^2), 空间复杂度是 O(1)。

而**一般的递归算法就要有 O(n)的空间复杂度了**，因为每次递归都要**存储返回信息**。

1. **冒泡排序,简单选择排序,堆排序,直接插入排序,希尔排序的空间复杂度为 O(1),**因为需要一个临时变量来交换元素位置,(另外遍历序列时自然少不了用一个变量来做索引)
2. 快速排序空间复杂度为 logn(因为递归调用了),归并排序空间复杂是 O(n),需要一个大小为 n 的临时数组。基数排序的空间复杂是 O(n),桶排序的空间复杂度不确定
