## Webpack生命周期及其实现过程

1. Webpack 是一个流行的前端打包工具，它提供了许多生命周期钩子来帮助开发者在构建项目时进行定制化处理。

### Webpack 生命周期简介

Webpack 生命周期主要分为以下 11 个阶段。这里需要注意区分dev和build模式。

### 分析一下webpack的生命周期

可以说Compiler.js这个类才是真正得控制了webpack打包的流程，如果说webpack.js所做的事是准备，那么Compiler就是撸起袖子就是干。

1. beforeRun，读取配置文件，准备启动；
   1. 这个async钩子，在这个钩子中绑定了读取文件的对象。
      1. `webpack --hot -w` => `{ hot: true, profile: false, watch: true,}`;
   2. config 的合并与插件加载；
      1. webpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中，并加载用户配置在 webpack.config.js 的 plugins 。
2. run，在编译之前有缓存，则启用缓存；
3. beforeCompile，开始编译前的准备，创建的ModuleFactory，创建Compilation，并绑定ModuleFactory到Compilation上。
   1. 同时处理一些不需要编译的模块，比如ExternalModule（远程模块）和DllModule（第三方模块）。
4. compile，编译了，这里的编译只是处理配置文件，生成基础的compilation；
5. seal 封装构建结果；
6. make，从Compilation的addEntry函数，开始构建模块；
   1. 这个钩子就是正式启动编译了，所以这个钩子执行完毕就意味这编译结束了，可以进行封装seal了。
7. afterCompile，编译结束了；
8. shouldEmit，获取compilation发来的电报，确定编译时候成功，是否可以开始输出了。
9. emit，输出文件了；
10. afterEmit，输出完毕；
11. done，无论成功与否，一切已尘埃落定。

### EntryOptionPlugin

EntryOptionPlugin是帮助我们处理入口类型的插件，他会webpack.config.js中entry的不同配置帮助我们搭配不同的EntryPlugin。通过entry配置进入的一共有3种类型，SingleEntryPlugin，MultiEntryPlugin和DynamicEntryPlugin，根据名字就能够轻易区分他们的类型。一般一个compiler只会触发一个EntryPlugin，然后在这个EntryPlugin中，会有我们构建模块的入口，也就是compilation的入口。

### other

1. beforeRun在 Webpack 开始读取配置之前，该钩子将被调用。
   1. 初始化参数 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数
2. run在 Webpack 开始编译时，该钩子将被调用。
3. **watchRun在使用 webpack-dev-server 进行开发时，该钩子将被调用**。
4. beforeCompile在 Webpack 开始编译之前，该钩子将被调用。
5. compile在 Webpack 开始编译时，该钩子将被调用。
   1. 开始编译 用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译
      1. 确定入口 根据配置中的 entry 找出所有的入口文件
6. thisCompilation在创建新的 Compilation 对象时，该钩子将被调用。
7. compilation在编译时，每当 Webpack 生成一个新的 Compilation 对象时，该钩子将被调用。
8. emit在生成资源之前，该钩子将被调用。
9. afterEmit在生成资源之后，该钩子将被调用。
10. done在 Webpack 编译完成时，该钩子将被调用。
11. assetEmitted 生命周期钩子是在所有资源（如 JavaScript、CSS、图片等）都已经生成到输出目录中后，即 webpack 打包完毕后触发的。

### 参考文章

1. [手写Webpack生命周期及其实现过程](https://juejin.cn/post/7206487695123480635)

## webpack的生命周期

```js
// emit：所有文件的编译及转化都已经完成，包含了最终输出的资源，我们可以在传入事件回调的compilation.assets上拿到所需数据，其中包括即将输出的资源、代码块Chunk等等信息。

// 修改或添加资源
compilation.assets['new-file.js'] = {
  source() {
    return 'var a=1';
  },
  size() {
    return this.source().length;
  }
};

// afterEmit：文件已经写入磁盘完成


// parse阶段，文件转为ast树解析处import、export等；


```

## [JavascriptParser Hooks](https://webpack.docschina.org/api/parser/)

[Webpack JavaScriptParser Hooks 使用小结](https://juejin.cn/post/7117837829165547556)

1. Webpack 在将代码转换为 AST 的同时为我们提供了 JavaScriptParser 钩子函数，以便开发者能够分析模块依赖，并根据自己的需求替换或添加依赖。

### MetaProperty && 自由变量

1. 在 JavaScript 中，如果某个作用域中使用了变量 a，但变量 a 并未在该作用域中声明，那么变量 a 即为自由变量。
2. MetaProperty：如果看 ESTree Spec MetaProperty 的解释，相信大家直接会晕掉，通过翻看 acorn 的实现可知，MetaProperty 指的就是 new.target 和 import.meta 属性；
   1. new.target：该属性常用来检测函数是否是通过 new 运行符被调用的，在通过 new 运算符初始化的函数中，new.target 返回一个指向该函数的引用，在普通的函数调用中，new.target 为 undefined。
   2. import.meta：通过 import.meta 可获得当前模块的元信息，该属性只能在模块内部使用，常用属性有；
      1. import.meta.url：在浏览器环境下返回模块所在的 URL 路径，在 Node.js 环境下返回模块所在的本地路径（以 file:/ 开头）；
      2. import.meta.scriptElement：仅在浏览器下可用，返回加载该模块的 <script> 元素，作用等同于 document.currentScript。

### 可通过 NormalModuleFactory 获取 JavaScriptParser 实例

上例代码清晰明了，不过多阐述，只对 for 中参数的可用值进行简短介绍：

1. javascript/auto：处理 CommonJS、AMD 及 ESModule 格式的 JavaScript 模块及其依赖；
2. javascript/dynamic：处理 CommonJS 及 AMD 格式的 JavaScript 模块及其依赖；
3. javascript/esm：处理 ESModule 格式的 JavaScript 模块及其依赖。

### 钩子列表

1. 有些钩子无需调用 for 方法）；
2. evaluateTypeof：将对自由变量（或其属性）、new.target（或其属性）、import.meta（或其属性）执行 typeof 操作赋值给某一变量（或作为 if 语句的判断条件）时触发；
3. statement：通用钩子，每解析一个语句调用一次；

## dependencyTemplates

Dependency Templates 是 Webpack 4 中引入的一个新特性，它允许您使用 JavaScript 代码来定义 Webpack 构建过程中的依赖关系。 Dependency Templates 可以帮助您更灵活地处理依赖关系，并提高构建速度。

Dependency Templates 是通过 webpack.DependencyTemplates 配置项来配置的。您可以使用 JavaScript 代码定义一个或多个 Dependency Templates，并将它们添加到 webpack.config.js 文件中。
