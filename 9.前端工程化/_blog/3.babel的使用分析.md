## babel

我们现在需要做的就是对的到的js文件进行增删改查，这里自然会想到使用直接对js文件尽性读取，然后匹配到文件后直接修改字符串，但是这样不安全，容易过多的匹配，或者修改后的结果不对。

1. babel介绍；
   1. Babel 是一个 JavaScript 编译器；
   2. Babel 是一个工具链，主要用于将采用 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。
   3. 当然我们这里不关心js代码的转换问题，主要要使用babel工具，对代码进行分析处理；
      1. 当然也可以自己写处理工具对代码进行处理，这里为了方便直接使用babel；
         1. 一些如正则匹配批量处理，然后使用`prettier`格式化代码后，也是比较可操作的，但是不安全，有时候会有一些语法的错误产生；
2. babel主要的操作方法，工具包；
3. 插件开发；
4. 开发的一些小功能；
   1. 获取页面结构的输出；
   2. 插入一些自己的小功能；
   3. 。。。

### 我们使用AST树操作去修改源码时，一般分为三个步骤

1. parser: 将代码字符串转换为AST树，即生成一个JSON对象
2. transform: 使用工具对生成的AST树进行增删查改等操作
3. generate: 将修改完毕的AST树重新转换为源码字符串

### babel工具包，这里主要用到的一些babel

1. [@babel/parser](https://www.babeljs.cn/docs/babel-parser)；
   1. 将代码转为ast；
   2. babel之前的版本是直接调用了recast库，来生成的AST。现在的@babel/parser很大程度借鉴了acorn。
2. [@babel/traverse](https://babeljs.io/docs/babel-traverse)；
   1. 这个库主要是遍历AST，操作Node上的节点。
   2. [Babel源码解析之@babel/traverse](https://juejin.cn/post/7041069084292677663/)；
   3. `traverse(ast, opts)`；
      1. 如果opts的key为enter/exit，在进入每一个节点的时候都会调用此函数，如果key为Node.type，则只有在解析到对应的节点时才调用此函数。
3. [@babel/types](https://www.babeljs.cn/docs/babel-types)；
   1. 对上边的ast进行遍历操作；
   2. types已经集成到@babel/core里，当然也可以单独安装；
   3. @babel/types的用途主要有3种：
      1. 类型集合
      2. 类型判断
      3. 创建节点
   4. [@babel/types深度应用](https://juejin.cn/post/6984945589859385358#heading-4)
   5. 一些常用的方法(主要是一些元素的判断&生成)：
      1. type.jsxAttribute
      2. type.jsxIdentifier
      3. type.stringLiteral
      4. type.jsxElement
      5. type.jsxOpeningElement
      6. type.jsxClosingElement
      7. type.jsxText
      8. type.objectProperty
      9. type.identifier
      10. type.callExpression
      11. type.memberExpression
      12. type.isJSXElement(node)
4. [@babel/generator](https://www.babeljs.cn/docs/babel-generator)；
   1. Turns an AST into code.
   2. path是一个对象，它表示两个节点之间的关联，我们可以通过path.node来访问其节点属性、通过path.parentPath访问其父路径等等；
5. [babel-core] / [@babel/core](https://babeljs.io/docs/babel-core):
   1. Since Babel 7 the Babel team switched to scoped packages, so you now have to use @babel/core instead of babel-core.
   2. But in essence, @babel/core is **just a newer version of babel-core**.
   3. babel的使用方式有多种：
      1. 可以直接引入核心库@babel/core，通过调用babel.transformSync等方法进行转化。
      2. 引入脚手架@babel/cli和核心库@babel/core，通过`npx babel src --out-dir lib`等方式进行转化；
   4. @babel/core是babel的核心，**主要起串联的作用，功能包括加载配置、调用@babel/parser解析AST、调用@babel/traverse遍历并操作AST、调用@babel/generator生成代码**。
   5. 我们顺便看一下@babel/core所暴露出的API。主要有以下几种：
      1. transform，参数为code，进行转换
         1. code是字符串类型的代码；
      2. transformFile，参数为文件名
      3. transfromFromAst，参数为AST
      4. parse，参数为code，生成AST

#### types的常用方法

类型创建:

```js
log(types.stringLiteral('string'))
log(types.numericLiteral(10e4))
log(types.booleanLiteral(0.5 > Math.random()))
log(types.regExpLiteral('\\.jsx?$', 'g'))

// =>

console.log(gen(node).code)
```

### AST

/Users/qiuwww/code/learn/blog/9.前端工程化/AST抽象语法树

#### 简单理解一下操作的过程

如下的一段代码，如果我们想在`console.log('hello');`后边添加一个输出`console.log('world');`，这个时候我们应该怎么做呢；

```js
export default function hello() {
  console.log('hello');
}
```

1. 首先我们要将其转唯ast，获取这段代码的语法树（parse）；
2. 首先我们找到声明为hello的函数，找到其body，在其最后边添加一个输出文本；（generate）
3. 然后通过工具将ast重新转为code；

### [babel在线工具](https://astexplorer.net/)，可以测试一下

### babel参考文档

1. <https://www.babeljs.cn/docs/configuration>
2. [acorn](https://github.com/acornjs/acorn)
3. <https://astexplorer.net/，非常重要，这里还可以对css及html相关代码进行处理；>
4. [Babel AST代码转换、生成](https://blog.csdn.net/weixin_43294560/article/details/125443800)
5. [Babel源码解析之@babel/core](https://juejin.cn/post/7041068341754069006/)

## 修改节点

1. nodes.splice(i, 0,
2.

## 代码分析

```js
export function parseContent(code) {
  return parser.parse(code, {
    sourceType: 'module',
    plugins: ['jsx', 'decorators-legacy', 'typescript', 'classProperties', 'dynamicImport'],
  });
}
```
