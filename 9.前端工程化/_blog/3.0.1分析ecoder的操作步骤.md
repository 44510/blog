## 3.0.1分析ecoder的操作步骤

这里本质上是直接修改了源文件，并不是基于webpack修改的中间输出。

1. 这里通过server（node）来修改文件
2. 通过plugin来计算修改的文件。

### 1. 分析如下的两块内容

1. 主要分析一下这块的内容：/Users/qiuwww/code/eazytec/ECoder/Eui-Server/app/service/eui.js；

2. /Users/qiuwww/code/eazytec/ECoder/Eui-Server/app/extend/helper.js
3. /Users/qiuwww/code/eazytec/ECoder/Eui-Server/e-ui-plugin，这里就是前台调用的接口；

主要分析ECoder/Eui-Server的接口，这里的接口承接了app的修改，所有的地方都要走到这里。

### 基本的逻辑

1. Eui-Server主要用来接受前端的接口请求，然后去截取并修改当前开发模式的代码；

### Ecoder

1. 运行入口：
   1. dev模式开发的时候的入口：`"electron-start": "electron . --env dev",`；
   2. build成安装包之后的入口: `"main": "./mainProcess/index.js",`，沿着这里进行分析；
      1. `app.on('ready', () => {`，ready之后开始执行相关的内容；
         1. 创建主要的窗口`const mainWindow = createMainWindow(app);`：
            1. `exports.createMainWindow = function createMainWindow(app) {`；
            2. 到这里只是打开主线程，并且打开主窗口；
      2. 通过router找到第一个打开的页面`ECoder/config/config.js`；
         1. 可以看到打开的第一个页面为index；
            1. 这里会有拉取在线模板，在本地生成项目；
               1. `onOpenCreateProject = () => {`
      3. 运行一个项目`onStart`，`ECoder/src/pages/Engineering/components/Task/index.js`，这里是核心的代码；
         1. 核心执行命令：

          ```js
            this.runCmd(`npx cross-env UMI_UI=none EUI_SERVER_PORT=${EUI_SERVER_PORT} umi dev`, () => {
              console.log(`${MANAGEMENT} run ${script}: success`);
            });
          ```

         2. 这里输出了一个EUI_SERVER_PORT变量，用于开启服务；
         3. 这里本地想要测试就需要一个umi的项目，然后加入自己的插件；

      4. /Users/qiuwww/code/eazytec/ECoder/src/layouts/GlobalBar.js，这里启动euiSERver；
         1. 真正的命令，**运行服务端代码**，服务端代码的运行`/Users/qiuwww/code/eazytec/ECoder/Eui-Server/package.json`:dev；
         2. 这里启动后可以访问到：`http://localhost:8002/`，属于插入的部分页面；
         3. euiEmitSocket，在server的web项目中构建socket.io连接；
         4. 接口的服务地址：<http://127.0.0.1:7001/；>
         5. 这里边记录了所有的修改的操作`ECoder/Eui-Server/app/router.js`，主要的操作如下；
            1. 添加区块到项目的页面中；
            2. 添加布局到项目中；
            3. 添加页面到项目中；
               1. 需要修改router；
               2. 复制页面到目标位置；
            4. 修改全局样式文件，也就是修改config/defaultSettings.js文件；
            5. 设置=>工程的一些基础配置修改；
         6. 这里的添加有两种模式，开发和保存确认；
            1. 最下边有一个保存的按钮；
         7. **这里是与umi强绑定的，并不是直接修改webpack的内容的**；
            1. 这里主要对应umi-plugin进行开发；
            2. [umi中的插件和路由机制](https://zhuanlan.zhihu.com/p/70309291)；

      5. **运行目标项目的代码**(这里是非侵入的，所以目标项目不需要任何的注入代码，只需要启动在7003上边就可以了),其实就是`/Users/qiuwww/code/eazytec/ECoder/Edit-Server/template`项目：
         1. 运行指令`npx cross-env UMI_UI=none EUI_SERVER_PORT=7003 umi dev`；
            1. 需要给项目注入EUI_SERVER_PORT，以便里边的插件；
         2. /Users/qiuwww/code/eazytec/ECoder/Edit-Server/template/config/config.js，这里控制使用的插件；
            1. 实际运行的项目中会有一个插入的dev的插件来处理；
         3. 这里要注入插件（没有需要注入的插件，需要的前端及后端的代码都在eui-server里边了）；
      6. 具体的一些操作，现在其实可以参考umi的操作来实现自己的目的：
         1. 初始化，将实际项目的参数传递给服务端eui-server；
         2. 获取routes：`api.getRoutes()`，存储在routeComponents；
         3. api.addEntryCode，在入口文件最后添加代码。；
            1. 参看源码；
            2. addEntryImports、addEntryCodeAhead、addHTMLMetas、modifyDevHTMLContent，这里其实就有很多封装好的方法供给使用；
            3. modifyRoutes；
            4. onGenerateFiles 生成临时文件，触发时机在 webpack 编译之前；
         4. 给开发中的代码添加socket通信模块`api.addEntryCodeAhead`；

```js

//  writeTmpFile(file, content) {
//     const { paths } = this;
//     const path = join(paths.absTmpDirPath, file);
//     mkdirp.sync(dirname(path));
//     writeContent(path, content);
//   }

// 部分方法的源代码
  writeTmpFile(file, content) {
    const paths = this.paths;
    const path = (0, _path().join)(paths.absTmpDirPath, file);

    _mkdirp().default.sync((0, _path().dirname)(path));

    (0, _writeContent.default)(path, content);
  }

  // ECoder/umi-plugin/umi-build-dev/src/routes/getRouteConfig.js，这里是核心的代码，这里可以看出，获取routes是通过读配置或者文件获取的，相关的配置是初始化配置文件获取的.umirc.js或者config/*；

  // ECoder/umi-plugin/umi-build-dev/lib/plugins/commands/getRouteManager.js，这里是这个管理器的目标文件；

  // function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  // var _getRouteManager = _interopRequireDefault(require("./plugins/commands/getRouteManager"));
  getRoutes() {
    const RoutesManager = (0, _getRouteManager.default)(this);
    RoutesManager.fetchRoutes();
    return RoutesManager.routes;
  }

  // 仍然没看明白怎么操作的

  // ECoder/umi-plugin/umi-build-dev/src/Service.js
  // const pluginHooks = this.service.pluginHooks;
  //   pluginHooks[hook] = pluginHooks[hook] || [];
  //   pluginHooks[hook].push({
  //     fn
  //   });
  // register(hook, fn) {
  // if (type === this.API_TYPE.ADD) {
  // this.register(name, opts => {
  //   return (opts.memo || []).concat(typeof args[0] === 'function' ? args[0](opts.memo, opts.args) : args[0]);
  // });

  // registerMethod(name, opts) {
  // this.registerMethod(method, {
  //   type
  // });
  // type = this.API_TYPE.ADD;
  // addEntryCode，这个方法似乎是统一注册的多个
  // ECoder/umi-plugin/umi-build-dev/src/PluginAPI.js，这里统一注册的
  api.addEntryCode(() => {
    return `console.log('works!')`;
  });

  
```

## (0, _assert().default)(!this[name], `api.${name} exists.`)

这是一种什么意思？

```js
function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function _assert() {
    return data;
  };

  return data;
}


// (0, function add() {}) => function add() {}
// (0, function add(a, b) {console.log(a,b)})(1, 2)  // 1, 2
```

```js
// https://stackoverflow.com/questions/40967162/what-is-the-meaning-of-0-somefunction-in-javascript
// javascript_冷知识之_(0, function)(param) https://blog.csdn.net/qq_39446719/article/details/103838706 大致了解这种写法的作用是强制改变 this 的指向。
// (0, function)(param) 会将 this 指向全局对象，也就是 window 或者 global。

(function() {
  (0, eval)("var foo = 123"); // indirect call to eval, creates global variable
})();
console.log(foo);            // 123


(function() {
  eval("var bar = 123");     // direct call to eval, creates local variable
})();

console.log(bar);            // ReferenceError
```

```js
const test = {
  fn(){
   console.log(this)
  }
 }

 test.fn() // this指向test
 (test.fn)() // this指向test
 (0,test.fn)() // 第一个括号里面的代码被当成了一个表达式。 this指向window 严格模式this是undefined
```

## ECoder/Eui-Server/e-ui-plugin/wrapper.js

就是入口ui，会在umi的插件执行的过程中被加入到页面内，只会在入口处通过如下的代码被注入进去：

```js

document.querySelector('body').appendChild(iframeWrapper);
ReactDOM.render(<EuiWrapper />, document.getElementById('EuiIframeWrapper'));
  
```

## 总的来说

1. eui-server启动项目；
   1. io服务端接口；
   2. web，就是插入的修改辅助页面；
2. e-ui-plugin插件，用于在引入的项目中对umi处理的项目进行代码注入；
   1. 这里的操作基于umi的插件开发的一些方法，可以直接在输出文件中引入包、注入js等；
   2. 在当前项目内建立与server的io通信；
   3. 添加了一个iframe，用于承载前面的web服务；
3. 入口按钮点击 => 打开修改面板 => 选择页面位置；
   1. 插入的位置，只能是`.g_euiAddBlockFlagStyle`这样的类型；
   2. GUmiUIFlag，这个方法是关键；
   3. 这里的index（位置），其实是按照一般组件的同级索引进行排序的；

### 对应如下两个包直接看就中了

1. const parser = require('@babel/parser');
2. const t = require('@babel/types');

## 分析如下的代码

```js
api.modifyAFWebpackOpts(memo => {
    generateRouteComponents();
    console.log('paths.cwd:', paths.cwd);
    // 
    memo.extraBabelPlugins = [

```
