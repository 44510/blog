[学习官方文档](https://webpack.docschina.org/api/compiler-hooks/)。

1. 什么是tapable；

## 自定义webpack的插件

1. 插件开发的原理
2. 几个主要的对象；
3. 开发基础的示例
   1. 前中后各个阶段的代码处理；

插件 是 webpack 的 支柱 功能。Webpack 自身也是构建于你在 webpack 配置中用到的 相同的插件系统 之上！

插件目的在于解决 loader 无法实现的其他事。Webpack 提供很多开箱即用的 插件。

**开发插件时最重要的两个概念是 compiler 编译器和 compilation 编译对象**。理解它们的角色是扩展 webpack 引擎重要的第一步。

一旦我们可以深入理解 webpack compiler 和每个独立的 compilation，我们依赖 webpack 引擎**将有无限多的事可以做**。我们可以重新格式化已有的文件，创建衍生的文件，或者制作全新的生成文件。

### 插件的不同类型

1. webpack 插件可以**按照它所注册的事件分成不同的类型**。每一个事件钩子都预先定义为同步、异步、瀑布或并行钩子，钩子在内部用 call/callAsync 方法调用。支持的钩子清单或可被绑定的钩子清单，通常在 this.hooks 属性指定。

### [compiler 钩子](https://webpack.docschina.org/api/compiler-hooks/)

1. [compiler 钩子](https://webpack.docschina.org/api/compiler-hooks/)；
2. Compiler 模块是 webpack 的主要引擎，它通过 CLI 或者 Node API 传递的**所有选项****创建出一个 compilation 实例**。
3. 它扩展（extends）自 Tapable 类，**用来注册和调用插件**。 **大多数面向用户的插件会首先在 Compiler 上注册**。
4. 具体就是**依次调用插件的 apply 方法**，并将 compiler 对象 (包含webpack的各种配置信息) 传进去供 plugin 使用，**compiler 包含整个构建流程的全部钩子，通过它可以把控整个 webpack 构建周期**。
5. 在运行期间 compiler **会根据 webpack 不同阶段触发的各种事件钩子**，执行插件附加/绑定在 hook 上的函数。
6. **compiler 只是负责维持生命周期运行的功能**，所有的加载、打包和写入工作，都被委托到注册过的插件上了。
7. webpack 使用 WebpackOptionsDefaulter 和 WebpackOptionsApply 来配置 Compiler 实例以及所有内置插件。
8. Compiler 类实例化并注册 plugins 后，**若 webpack 函数接收了回调callback，会执行compiler.run()方法**，webpack即刻开启编译之旅。如果未指定callback回调，则需要用户自己调用run方法来启动编译。

此模块会暴露在 webpack.Compiler，可以直接通过这种方式使用。

查看webpack的源码。

### Compiler

1. Compiler类(./lib/Compiler.js)：webpack的主要引擎，扩展自Tapable。
2. **webpack 从执行到结束，Compiler只会实例化一次**。生成的 compiler 对象记录了 webpack 当前运行环境的完整的信息，该对象是全局唯一的，**插件可以通过它获取到 webpack config 信息，如entry、output、loaders等配置**。
   1. 这里的插件的config信息，会合并插件初始化的时候的参数；
3. Compiler 有几个重要的方法，watch和run是启动/执行 webpack 构建的函数，而compile是负责编译的。 它触发 compile 钩子**并实例化了一个 compilation**，再触发自己的 make 钩子把 compilation 对象作为参数传过去。

4. 在 compiler 类中，提供了三种类型的内置解析器：
   1. normal: 通过绝对或相对路径解析模块。
   2. context: 在给定的上下文中解析模块。
   3. loader: 解析 webpack loader。
   4. **请注意，resolve 配置会影响 normal 解析器和 context 解析器**，**而“ resolveLoader 用于修改 loader 解析器**。

#### 监听(watching)

1. Compiler 支持可以监控文件系统的 监听(watching) 机制，并且在文件修改时重新编译。
2. 当处于监听模式(watch mode)时， compiler 会触发诸如 watchRun, watchClose 和 invalid 等额外的事件。

### Tapable 类

1. 它是一个管理钩子事件监听与触发的小型库，**export 了许多Hook类**(hook 构造函数)，如 SyncHook、SyncBailHook 等，可以用来为插件创建 hooks。
2. 整体类似发布订阅模式。
   1. tap: (name: string | Tap, fn: (context?, ...args) => Result) => void
      1. 同步 hook 只能使用 tap 方法；
   2. tapAsync: (name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void
      1. 当我们用 tapAsync 方法来绑定插件时，_必须_调用函数的最后一个参数 callback 指定的回调函数。
   3. tapPromise: (name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void
      1. 当我们用 tapPromise 方法来绑定插件时，_必须_返回一个 pormise ，异步任务完成后 resolve 。

```ts
interface Tap {
    name: string,
    type: string
    fn: Function,
    stage: number,
    context: boolean,
    before?: string | Array
}
```

#### 同步与异步hook

1. 同步 hook 只能使用 tap 方法；
2. 而异步 hook 除了 tapAsync 和 tapPromise 这些异步方法，也支持用 tap 方法让 hook 以同步方式运行。
   1. **当我们使用 tapPromise method来访问插件时，则需要返回一个promise**，它可以在异步任务完成时解决。
3. **我们可以有多种方式 hook 到 compiler 中**，hook将编译一个方法，可以让各种插件都以最合适有效的方式去运行。
4. 创建钩子的方法：`const hook = new SyncHook(["arg1", "arg2", "arg3"])`；
5. 在 webpack 运行特定阶段(比如 compiler.run 和 compile)通过call、callAsync、promise调用这些 hook，**声明注册在这个 hook 上的插件 (内的方法) 触发的时机**。类实似于发布-订阅模式中的**发布事件**。
6. 插件通过tap、tapAsync等方法订阅 Compiler 或 Compilation 实例的 hook，方法内可以调用 api 进行一些处理。
7. 也就是说这里的hook**通过tap相关方法进行订阅**，**发布是通过apply或者call来进行**；
   1. plugin.call(compiler, compiler);
   2. plugin.apply(compiler);

### compilation / [compilation 钩子](https://webpack.docschina.org/api/compilation-hooks/)

1. Compilation 模块会被 Compiler 用来创建新的 compilation 对象（或新的 build 对象）。 compilation 实例能够访问所有的模块和它们的依赖（大部分是循环依赖）。
2. **在编译阶段，模块会被加载(load)、封存(seal)、优化(optimize)、 分块(chunk)、哈希(hash)和重新创建(restore)**。
3. Compilation类(./lib/Compilation.js)：扩展自Tapable，也提供了很多关键点回调供插件做自定义处理时选择使用拓展。
4. 一个 compilation 对象**代表了一次单一的版本构建和生成资源**，它储存了当前的模块资源、编译生成的资源、变化的文件、以及被跟踪依赖的状态信息。
5. 简单来说，Compilation的职责就是对所有 require 图(graph)中对象的**字面上的编译**，**构建 module 和 chunk**，并利用插件优化构建过程，同时把本次打包编译的内容全存到内存里。
6. **compilation 编译可以多次执行**，**如在watch模式下启动 webpack，每次监测到源文件发生变化，都会重新实例化一个compilation对象**，从而生成一组新的编译资源。这个对象可以访问所有的模块和它们的依赖（大部分是循环依赖）。
7. [compilation 对象方法](https://webpack.docschina.org/api/compilation-object/#compilation-object-methods)。
   1. getStats；
   2. addModule；
   3. addEntry；
   4. finish；

### Compiler 和 Compilation 的区别

1. **compiler 对象代表的是构建过程中不变的 webpack 环境**，整个 webpack 从启动到关闭的生命周期。针对的是webpack。
2. **compilation 对象只代表一次新的编译**，只要项目文件有改动，compilation 就会被重新创建。针对的是随时可变的项目文件。
3. **如果把compiler算作是总控制台，那么compilation则专注于编译处理这件事上**。

### 常用到的插件的hook

1. emit：输出 asset 到 output 目录之前执行。这个钩子 不会 被复制到子编译器。
2. done.tap ：执行完成后执行这里；
3. compilation.tap：指定一个挂载到 compilation 的钩子，回调函数的参数为 compilation。

### 解析器（Resolvers）

1. 解析器是使用 enhanced-resolve 库创建的。Resolver 类 拓展了 tapable 类，并使用 tapable 来提供了一些钩子。

### ContextModuleFactory Hooks

1. Compiler 使用 ContextModuleFactory 模块从 webpack 独特的 require.context API 生成依赖关系。它会解析请求的目录，为每个文件生成请求，并依据传递来的 regExp 进行过滤。最后匹配成功的依赖关系将被传入 NormalModuleFactory。

### JavascriptParser Hooks

1. parser 实例，在 compiler 中被发现，是用来解析由 webpack 处理过的每个模块。parser 也是扩展自 tapable 的 webpack 类 并且提供多种 tapable 钩子。
