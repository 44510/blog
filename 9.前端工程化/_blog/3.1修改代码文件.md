## 插件开发-修改源文件

**这里的代码都是经过babel处理过的，其实还是挺难操作的。**

```js
// AboutView.vue文件的结果

// module.request /Users/qiuwww/code/learn/blog/9.前端工程化/webpack/webpack-vue2-plugin/node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!/Users/qiuwww/code/learn/blog/9.前端工程化/webpack/webpack-vue2-plugin/src/views/AboutView.vue
make succeedModule import { render } from "./AboutView.vue?vue&type=template&id=4cebd208"
import script from "./AboutView.vue?vue&type=script&lang=js"
export * from "./AboutView.vue?vue&type=script&lang=js"

import exportComponent from "../../node_modules/vue-loader/dist/exportHelper.js"
const __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__file',"src/views/AboutView.vue"]])
/* hot reload */
if (module.hot) {
  __exports__.__hmrId = "4cebd208"
  const api = __VUE_HMR_RUNTIME__
  module.hot.accept()
  if (!api.createRecord('4cebd208', __exports__)) {
    api.reload('4cebd208', __exports__)
  }

  module.hot.accept("./AboutView.vue?vue&type=template&id=4cebd208", () => {
    api.rerender('4cebd208', render)
  })

}
export default __exports__

module.request /Users/qiuwww/code/learn/blog/9.前端工程化/webpack/webpack-vue2-plugin/node_modules/vue-loader/dist/pitcher.js??ruleSet[1].rules[0]!/Users/qiuwww/code/learn/blog/9.前端工程化/webpack/webpack-vue2-plugin/node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!/Users/qiuwww/code/learn/blog/9.前端工程化/webpack/webpack-vue2-plugin/node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!/Users/qiuwww/code/learn/blog/9.前端工程化/webpack/webpack-vue2-plugin/node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!/Users/qiuwww/code/learn/blog/9.前端工程化/webpack/webpack-vue2-plugin/src/views/AboutView.vue?vue&type=template&id=4cebd208
make succeedModule export * from "-!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./AboutView.vue?vue&type=template&id=4cebd208"
module.request /Users/qiuwww/code/learn/blog/9.前端工程化/webpack/webpack-vue2-plugin/node_modules/vue-loader/dist/pitcher.js??ruleSet[1].rules[0]!/Users/qiuwww/code/learn/blog/9.前端工程化/webpack/webpack-vue2-plugin/node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!/Users/qiuwww/code/learn/blog/9.前端工程化/webpack/webpack-vue2-plugin/node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!/Users/qiuwww/code/learn/blog/9.前端工程化/webpack/webpack-vue2-plugin/src/views/AboutView.vue?vue&type=script&lang=js
make succeedModule export { default } from "-!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./AboutView.vue?vue&type=script&lang=js"; export * from "-!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./AboutView.vue?vue&type=script&lang=js"
module.request /Users/qiuwww/code/learn/blog/9.前端工程化/webpack/webpack-vue2-plugin/node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!/Users/qiuwww/code/learn/blog/9.前端工程化/webpack/webpack-vue2-plugin/node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!/Users/qiuwww/code/learn/blog/9.前端工程化/webpack/webpack-vue2-plugin/src/views/AboutView.vue?vue&type=script&lang=js
make succeedModule undefined
module.request /Users/qiuwww/code/learn/blog/9.前端工程化/webpack/webpack-vue2-plugin/node_modules/babel-loader/lib/index.js??clonedRuleSet-40.use[0]!/Users/qiuwww/code/learn/blog/9.前端工程化/webpack/webpack-vue2-plugin/node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[4]!/Users/qiuwww/code/learn/blog/9.前端工程化/webpack/webpack-vue2-plugin/node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!/Users/qiuwww/code/learn/blog/9.前端工程化/webpack/webpack-vue2-plugin/src/views/AboutView.vue?vue&type=template&id=4cebd208
```

Compiler 代表着 webpack 从启动到关闭的整个生命周期，**而 Compilation 只代表来一次编译，而修改源码的时机正好需要在编译的过程中修改**。

1. **通过 optimizeChunkAssets 的钩子可以拿到所有的 chunks 信息，针对具体的 chunks 可以修改对应的源码**。
   1. DeprecationWarning: optimizeChunkAssets is deprecated (use Compilation.hooks.processAssets instead and use one of Compilation.PROCESS_ASSETS_STAGE_* as stage option)。
   2. 插件提供了丰富的生命周期，在修改源码过程中也要特别要注意插件的生命周期带来的影响，比如**上述在 optimizeChunkAssets 阶段，这个阶段拿到的 chunk 资源已经完成各种 Loader 的处理，这个时候如果新增源码内容是 ES6，将不会再被转化**。
   3. **optimizeChunkAssets 阶段代码已经被打包过了**，我觉得不能称之为 【源码】。
   4. optimizeChunkAssets 钩子中修改源码可能引起问题，因为在此之前 hash 值已经生成。
2. 结合ast在loader中修改，这时的源码还没被webpack处理，可以增加其他依赖。
   1. 在webpack中通过插件修改，修改时机尽量的提前，可以在Chunk生成之前。
   2. uglifyjs修改代码的时机，是在optimizeChunkAssets阶段。
   3. webpack中使用acorn处理源码，主要目的是分析依赖处理依赖；如果需要添加依赖用loader处理添加，第二种方式可以直接处理源码，生成Chunk后webpack会在源码上添加其他的东西。

### 结合ast在loader中修改，这时的源码还没被webpack处理，可以增加其他依赖

### 实现一个防止代码被调试的插件。 思路，生产环境代码中注入debuger

### DeprecationWarning: Compilation.assets will be frozen in future, all modifications are deprecated

BREAKING CHANGE: No more changes should happen to Compilation.assets after sealing the Compilation.

根据提示可知，我们需要使用 Compilation 中的 processAssets hook 来对资源进行再处理。

### 修改代码的方式

```js

// 1. 在前后添加文件；

// 方法1，直接拼接数据
let source = compilation.assets[filename].source();
source = '/*这是我通过webpack plugin 在js文件中插入的一行代码*/\n' + source;

// 方法2，通过操作ast进行添加



```

## compiler.hooks.normalModuleFactory.tap，这里是可以获取到ast的结果的

Compiler.hooks.normalModuleFactory是 Webpack 中的一个钩子，它允许您在 Webpack 编译过程的特定阶段执行自定义逻辑。

**在 Webpack 中，每个模块都被表示为一个"Module"对象**。**Webpack 通过一个"ModuleFactory"来创建这些"Module"对象**。Compiler.hooks.normalModuleFactory钩子允许您在这个"ModuleFactory"中添加自定义逻辑，以影响 Webpack 编译过程中的模块创建过程。

Compiler.hooks.normalModuleFactory钩子在 Webpack 编译过程中的"Module"创建阶段被调用。**在这个阶段，Webpack 已经解析了模块的源代码，并将其转换为抽象语法树（AST）**。**但是，Webpack 还没有将该模块的代码实际编译为 JavaScript 代码**。

通过在Compiler.hooks.normalModuleFactory钩子中**添加自定义逻辑，您可以在 Webpack 编译过程中改变模块的行为，例如添加自定义代码、修改模块的依赖关系、注入自定义函数等**。

### 怎么将修改的结果印象到整体里边 / normalModuleFactory如何修改ast

Compiler.hooks.normalModuleFactory是 Webpack 中的一个钩子，它允许您在 Webpack 编译过程的特定阶段执行自定义逻辑。在这个钩子中，您可以修改抽象语法树（AST）。
**要修改 AST，您可以使用 Webpack 的normalModuleFactory钩子的factory方法。这个方法接受一个函数作为参数，该函数接受一个Compiler对象和一个Module对象作为参数。**在这个函数中，您可以使用Compiler对象的parser方法获取该模块的AST，并进行修改。
下面是一个示例，演示如何使用Compiler.hooks.normalModuleFactory钩子修改 AST：

```js
compiler.hooks.normalModuleFactory.tap('MyPlugin', function(Compiler, module) {
  var tree = Compiler.parser(module.src);
  // 修改 tree
  module.src = Compiler.outputOptions.sourceMap ? tree.toSource() : tree.toESM();
});
```

在上面的示例中，我们首先使用Compiler.parser方法获取该模块的AST。然后，我们可以根据需要修改该AST。最后，**我们使用Compiler.outputOptions.sourceMap选项来决定是否生成源代码映射（source map）**。**如果生成源代码映射，我们将修改后的AST转换为源代码，否则我们将其转换为 ECMAScript 模块（ESM）格式**。
请注意，修改 AST 可能会影响 Webpack 的编译结果，因此请谨慎使用。**如果您需要对 AST 进行大量修改，建议编写自己的 Webpack 插件来实现**。

## compiler.hooks.emit.tap('AssetsReplacePlugin'，这里是可以修改资源的结果的，一般通过返回source()方法的结果来修改

### compiler.hooks.normalModuleFactory与compiler.hooks.emit的区别

1. Compiler.hooks.normalModuleFactory钩子在 Webpack 编译过程中的"Module"创建阶段被调用。在这个阶段，Webpack 已经解析了模块的源代码，并将其转换为抽象语法树（AST）。但是，Webpack 还没有将该模块的代码实际编译为 JavaScript 代码。通过在Compiler.hooks.normalModuleFactory钩子中添加自定义逻辑，您可以在 Webpack 编译过程中改变模块的行为，例如添加自定义代码、修改模块的依赖关系、注入自定义函数等。
2. 相比之下，Compiler.hooks.emit钩子在 Webpack 编译过程的后期被调用。在这个阶段，Webpack 已经将所有的模块编译为 JavaScript 代码，并将它们合并到一个或多个文件中。
通过在Compiler.hooks.emit钩子中添加自定义逻辑，您可以在 Webpack 编译过程中改变输出文件的行为，例如添加自定义代码、修改输出文件的路径等。


总的来说，Compiler.hooks.normalModuleFactory钩子更适合用于改变模块的行为，而Compiler.hooks.emit钩子更适合用于改变输出文件的行为。您可以根据具体需求选择使用哪个钩子。
