## Tapable 类

1. 它是一个管理钩子事件监听与触发的小型库，**export 了许多Hook类**(hook 构造函数)，如 SyncHook、SyncBailHook 等，可以用来为插件创建 hooks。
2. 整体类似发布订阅模式。
   1. tap: (name: string | Tap, fn: (context?, ...args) => Result) => void
      1. 同步 hook 只能使用 tap 方法；
   2. tapAsync: (name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void
      1. 当我们用 tapAsync 方法来绑定插件时，_必须_调用函数的最后一个参数 callback 指定的回调函数。
   3. tapPromise: (name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void
      1. 当我们用 tapPromise 方法来绑定插件时，_必须_返回一个 pormise ，异步任务完成后 resolve 。

```ts
interface Tap {
    name: string,
    type: string
    fn: Function,
    stage: number,
    context: boolean,
    before?: string | Array
}
```

plugin的插入方式是Tapable. 我目前没有深入理解, 简单地认为他是一个发布订阅系统. 在webpack执行的过程中会在指定的一些地方调用指定的方法(并传入一些内部变量作为参数), 插件通过注册这些指定名字钩子, 来获取变量, 并调用api.
另外提一下, webpack内部很多功能也是通过Tapable的方式实现的, 所以甚至可以认为webpack plugin是webpack源码的扩展.

### Tapable 类

Webpack 的事件流机制应用了观察者模式，和 Node.js 中的 EventEmitter 非常相似。 Compiler 和 Compilation 都继承自 Tapable，可以直接在 Compiler 和 Compilation 对象上广播和监听事件。

1. 它是一个管理钩子事件监听与触发的小型库，**export 了许多Hook类**(hook 构造函数)，如 SyncHook、SyncBailHook 等，可以用来为插件创建 hooks。
2. 整体类似发布订阅模式。
   1. tap: (name: string | Tap, fn: (context?, ...args) => Result) => void
      1. 同步 hook 只能使用 tap 方法；
   2. tapAsync: (name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void
      1. 当我们用 tapAsync 方法来绑定插件时，_必须_调用函数的最后一个参数 callback 指定的回调函数。
   3. tapPromise: (name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void
      1. 当我们用 tapPromise 方法来绑定插件时，_必须_返回一个 pormise ，异步任务完成后 resolve 。

```ts
interface Tap {
    name: string,
    type: string
    fn: Function,
    stage: number,
    context: boolean,
    before?: string | Array
}
```

#### 同步与异步hook

1. 同步 hook 只能使用 tap 方法；
2. 而异步 hook 除了 tapAsync 和 tapPromise 这些异步方法，也支持用 tap 方法让 hook 以同步方式运行。
   1. **当我们使用 tapPromise method来访问插件时，则需要返回一个promise**，它可以在异步任务完成时解决。
3. **我们可以有多种方式 hook 到 compiler 中**，hook将编译一个方法，可以让各种插件都以最合适有效的方式去运行。
4. 创建钩子的方法：`const hook = new SyncHook(["arg1", "arg2", "arg3"])`；
5. 在 webpack 运行特定阶段(比如 compiler.run 和 compile)通过call、callAsync、promise调用这些 hook，**声明注册在这个 hook 上的插件 (内的方法) 触发的时机**。类实似于发布-订阅模式中的**发布事件**。
6. 插件通过tap、tapAsync等方法订阅 Compiler 或 Compilation 实例的 hook，方法内可以调用 api 进行一些处理。
7. 也就是说这里的hook**通过tap相关方法进行订阅**，**发布是通过apply或者call来进行**；
   1. plugin.call(compiler, compiler);
   2. plugin.apply(compiler);
