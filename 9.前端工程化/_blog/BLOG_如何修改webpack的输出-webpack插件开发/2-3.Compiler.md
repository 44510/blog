## [compiler 钩子](https://webpack.docschina.org/api/compiler-hooks/)

1. [compiler 钩子](https://webpack.docschina.org/api/compiler-hooks/)；
2. Compiler 模块是 webpack 的主要引擎，它通过 CLI 或者 Node API 传递的**所有选项\*\***创建出一个 compilation 实例\*\*。
3. 它扩展（extends）自 Tapable 类，**用来注册和调用插件**。 **大多数面向用户的插件会首先在 Compiler 上注册**。
4. 具体就是**依次调用插件的 apply 方法**，并将 compiler 对象 (包含 webpack 的各种配置信息) 传进去供 plugin 使用，**compiler 包含整个构建流程的全部钩子，通过它可以把控整个 webpack 构建周期**。
5. 在运行期间 compiler **会根据 webpack 不同阶段触发的各种事件钩子**，执行插件附加/绑定在 hook 上的函数。
6. **compiler 只是负责维持生命周期运行的功能**，所有的加载、打包和写入工作，都被委托到注册过的插件上了。
7. webpack 使用 WebpackOptionsDefaulter 和 WebpackOptionsApply 来配置 Compiler 实例以及所有内置插件。
8. Compiler 类实例化并注册 plugins 后，**若 webpack 函数接收了回调 callback，会执行 compiler.run()方法**，webpack 即刻开启编译之旅。如果未指定 callback 回调，则需要用户自己调用 run 方法来启动编译。

此模块会暴露在 webpack.Compiler，可以直接通过这种方式使用。

查看 webpack 的源码。

### Compiler

1. Compiler 类(./lib/Compiler.js)：webpack 的主要引擎，扩展自 Tapable。
2. **webpack 从执行到结束，Compiler 只会实例化一次**。生成的 compiler 对象记录了 webpack 当前运行环境的完整的信息，该对象是全局唯一的，**插件可以通过它获取到 webpack config 信息，如 entry、output、loaders 等配置**。
   1. 这里的插件的 config 信息，会合并插件初始化的时候的参数；
3. Compiler 有几个重要的方法，watch 和 run 是启动/执行 webpack 构建的函数，而 compile 是负责编译的。 它触发 compile 钩子**并实例化了一个 compilation**，再触发自己的 make 钩子把 compilation 对象作为参数传过去。

4. 在 compiler 类中，提供了三种类型的内置解析器：
   1. normal: 通过绝对或相对路径解析模块。
   2. context: 在给定的上下文中解析模块。
   3. loader: 解析 webpack loader。
   4. **请注意，resolve 配置会影响 normal 解析器和 context 解析器**，**而“ resolveLoader 用于修改 loader 解析器**。

#### 监听(watching)

1. Compiler 支持可以监控文件系统的 监听(watching) 机制，并且在文件修改时重新编译。
2. 当处于监听模式(watch mode)时， compiler 会触发诸如 watchRun, watchClose 和 invalid 等额外的事件。

webpack 插件开发主要基于 Tapable 的插件机制提供丰富的自定义 API 和生命周期事件，可以控制 webpack 编译的每个流程

Compiler 包含 webpack 环境的所有配置信息

Compilation 包含整个编译过程中所有环节对应的方法

## Compiler Hooks / 每个生命周期都是做什么用的，[compiler 钩子](https://www.webpackjs.com/api/compiler-hooks/)

Compiler 编译器模块是**创建编译实例的主引擎**。**大多数面向用户的插件都首先在 Compiler 上注册**。

1. **run** AsyncSeriesHook 在编译器开始读取记录前执行
2. **compile** SyncHook **在一个新的 compilation 创建之前执行**
3. **compilation** SyncHook **在一次 compilation 创建后执行插件**
4. **make** AsyncParallelHook **完成一次编译之前执行**
5. **emit** AsyncSeriesHook **在生成文件到 output 目录之前执行**，
   1. 回调参数： compilation
6. **afterEmit** AsyncSeriesHook 在生成文件到 output 目录之后执行
7. **assetEmitted** AsyncSeriesHook 生成文件的时候执行，提供访问产出文件信息的入口，回调参数：file，info
8. **done** AsyncSeriesHook 一次编译完成后执行，回调参数：stats

### 其他重要的钩子

1. normalModuleFactory：NormalModuleFactory 创建之后调用`compiler.hooks.normalModuleFactory`:
   1. 回调参数：normalModuleFactory；

### 重要的属性，[compilation-object](https://www.webpackjs.com/api/compilation-object/#compilation-object-methods)

编译（compilation）通常是指构建过程的单个执行实例，其中包括从源代码到目标代码的所有操作。在大多数情况下，编译代表一次构建任务，可能包括多个模块的处理。编译可以具有不同的属性和状态，如编译错误、警告、优化级别等。

在编译器的回调函数中，"compilation" 属性通常表示整个编译任务。

1. 模块（modules）
   1. 而 "modules" 属性包含了构建过程中的所有模块（也通常以对象的形式表示）。
   2. 通常指构建过程中的**源代码文件或代码单元**，它们可以是 JavaScript 模块、CSS 文件、图像文件等。模块通常是构建过程的输入，它们可以相互依赖并被打包到不同的代码块中。在前端开发中，模块通常使用 ES6 模块系统或 CommonJS 模块系统来组织和导入/导出代码。
2. chunks（代码块）
   1. "chunks" 属性包含了**构建生成的不同代码块**（通常以对象的形式表示）。
   2. 代码块（chunks）通常**是指构建过程中生成的独立的代码文件或资源文件**，这些文件可以在浏览器端或服务器端使用。
   3. 在前端构建中，代码块通常对应于不同的页面或入口点，每个代码块可能包含了与特定页面或功能相关的 JavaScript、CSS 和其他资源。在后端构建中，代码块可以代表不同的模块或库。

## Compiler Hooks 的理解

"Compiler Hooks" 是编译器（通常是指编程语言的编译器或构建工具）中的一种机制，**用于允许开发者在编译或构建过程的不同生命周期阶段插入自定义逻辑**。这些生命周期阶段通常与编译或构建过程的不同步骤相关，**允许你执行特定的操作或修改代码**。

每个编译器或构建工具的生命周期阶段可以有不同的名称和数量，具体取决于工具的设计和用途。以下是通常存在于编译器或构建工具生命周期中的一些典型阶段以及它们的用途：

1. **初始化（Initialization）**：在编译或构建过程开始之前，通常会执行一些初始化操作，如加载配置、设置环境变量等。
2. **词法分析（Lexical Analysis）**：在此阶段，源代码被分析为词法单元（tokens），这些词法单元通常是语法分析的基础。
3. **语法分析（Syntax Analysis）**：在这个阶段，编译器会将词法单元组织成抽象语法树（AST），以表示源代码的结构。
4. **语义分析（Semantic Analysis）**：在这个阶段，编译器会检查源代码的语义正确性，如类型检查、作用域分析等。
5. **优化（Optimization）**：编译器可能会对生成的中间表示或目标代码进行优化，以提高程序的性能或减小代码的体积。
6. **代码生成（Code Generation）**：在这个阶段，编译器将中间表示（如 AST 或中间代码）翻译成目标代码，通常是机器代码或字节码。
7. **链接（Linking）**：对于需要多个源文件的项目，编译器会将它们链接在一起，以生成最终可执行文件或库。

每个生命周期阶段都可以用来插入自定义逻辑或操作，以扩展编译器或构建工具的功能。这些自定义操作通常通过编写插件、扩展或使用钩子（Hooks）来实现。例如，你可以在词法分析阶段添加自定义词法分析器，或在优化阶段添加自定义优化规则。

具体的编译器或构建工具会提供不同的接口或机制来支持这些生命周期阶段的自定义操作，因此具体实现方式会根据工具而异。
