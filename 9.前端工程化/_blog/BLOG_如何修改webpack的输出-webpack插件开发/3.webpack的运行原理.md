## webpack 的基本原理

webpack 的工作原理可以概括为：从入口文件开始，分析依赖关系，通过加载器处理不同类型的模块，通过插件执行各种任务，最终输出打包后的文件。webpack 的强大之处在于其高度可配置性和可扩展性，允许开发者根据项目需求定制构建流程，从而满足不同项目的需求。

### webpack 的生命周期 / webpack 运行的基本流程

webpack 的生命周期是指 webpack **在执行其构建任务时所经历的一系列阶段**。这些生命周期钩子来帮助开发者在构建项目时进行定制化处理。webpack 的运行也是基于这些阶段进行的。这些阶段包括：

1. 初始化阶段（ Initialization Phase ）：webpack 在这个阶段中会解析配置文件，并初始化一些全局变量和模块；
   1. **这里就是整合所有的配置信息的阶段**，这些全局、插件、babel 的配置信息会被整合到一起，给后续使用；
2. 解析阶段（ Parse Phase ）：webpack 在这个阶段中会**解析所有的输入文件**，包括 JavaScript、CSS、图像等。**它会将这些文件解析成抽象语法树（AST）**，以便进行进一步的处理；
   1. **这里其实就是 bebel 处理的阶段**，这里的资源在 bebel 处理之后都是一团一团的代码块；
   2. 这里的 ast 可能还需要对这里的代码块进行处理，继续解析成 ast；
3. 变换阶段（ Transform Phase ）：webpack 在这个阶段中会应用一些变换，**例如代码压缩、语法转换等**。这些变换是通过插件实现的，webpack 会在这个阶段中调用相应的插件来执行这些变换；
   1. 插件的工作阶段；
4. 代码分离阶段（ Code Splitting Phase ）：如果配置了**代码分离**，webpack 会在这个阶段中**将大型的 JavaScript 文件分割成多个较小的文件，以便在浏览器中按需加载**；
   1. 进行如按需加载、判断依赖、分割代码等操作；
5. 生成阶段（ Generate Phase ）：webpack 在这个阶段中会根据配置文件中的规则，**生成最终的输出文件**。这些文件可以是 JavaScript 文件、CSS 文件、图像文件等；
6. 浏览器加载阶段（ Load Phase ）：webpack 在这个阶段中会加载生成的输出文件，并将它们注入到浏览器中；
   1. dev 模式的热更新。

这些阶段是 webpack 构建过程的核心，它们共同协作以完成 webpack 的构建任务。了解这些阶段可以帮助你更好地理解 webpack 的工作原理，并更好地使用它来构建你的项目。

### webpack 的生命周期钩子

webpack 最重要的两个资源就是 compiler 和 compilation 对象。理解它们的角色是扩展 webpack 引擎重要的第一步。

Compiler 和 Compilation 都继承自 Tapable，可以直接在 Compiler 和 Compilation 对象上广播和监听事件。

Tapable 的机制应用了观察者模式，和 Node.js 中的 EventEmitter 非常相似。

#### [Tapable 类](https://webpack.docschina.org/api/plugins/#tapable)

`Tapable` 是 webpack 内部使用的一个插件系统，**它提供了一种灵活的方式来管理和应用插件，以扩展和定制 webpack 的行为**。`Tapable` 实际上是 webpack 插件系统的核心，而插件系统是 webpack 构建过程的基础。

以下是一些关于 `Tapable` 类的基本介绍和概念：

1. **事件驱动体系**：`Tapable` 是一个事件驱动的插件系统，它允许你在不同的生命周期阶段监听和触发事件。这些事件对应 webpack 构建过程中的不同阶段，如编译、模块解析、资源生成等。
2. **插件**：在 `Tapable` 中，插件是一个具有特定方法的 JavaScript 对象。插件可以监听事件，并在事件发生时执行自定义逻辑。这使得开发者可以扩展 webpack 的功能，以满足特定项目需求。
3. **事件监听和触发**：`Tapable` 提供了一系列的方法，如 `tap`、`tapAsync`、`tapPromise` 等，用于监听事件。开发者可以使用这些方法将插件注册到事件上。然后，webpack 在相应的生命周期阶段触发事件，并执行已注册的插件。
4. **异步支持**：`Tapable` 提供了异步事件处理的机制，使插件可以执行异步操作。这对于一些耗时的操作，如文件读写、网络请求等，非常有用。
5. **钩子（Hooks）**：`Tapable` 使用钩子来管理事件，每个事件对应一个钩子。钩子提供了标准的 API，使插件开发更加一致和易于理解。常见的钩子包括 `SyncHook`、`AsyncSeriesHook`、`AsyncParallelHook` 等，它们分别用于同步事件、异步串行事件和异步并行事件。
6. **内置钩子**：webpack 内部使用了大量的内置钩子来管理构建过程，同时也允许开发者自定义钩子来扩展功能。

`Tapable` 的强大之处在于它为 webpack 插件提供了一种松耦合的扩展机制，使得开发者可以通过插件来干预 webpack 的构建过程，而不需要修改 webpack 的源代码。这使得 webpack 可以适应各种不同的项目需求，从简单的静态资源打包到复杂的前端工程化和优化。

总之，`Tapable` 是 webpack 插件系统的核心，它为 webpack 提供了一种高度可扩展的机制，使得开发者可以通过插件来自定义和扩展 webpack 的行为。

```ts
interface Tap {
  name: string;
  type: string;
  fn: Function;
  stage: number;
  context: boolean;
  before?: string | Array;
}
```

##### 钩子的类型

1. `tap: (name: string | Tap, fn: (context?, ...args) => Result) => void`；
   1. 同步 hook 只能使用 tap 方法；
2. `tapAsync: (name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void`；
   1. 当我们用 tapAsync 方法来绑定插件时，*必须*调用函数的最后一个参数 callback 指定的回调函数。
3. `tapPromise: (name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void`；
   1. 当我们用 tapPromise 方法来绑定插件时，*必须*返回一个 promise ，异步任务完成后 resolve 。

#### Compiler 和 Compilation 的关系

1. **compiler 对象代表的是构建过程中不变的 webpack 环境**，整个 webpack 从启动到关闭的生命周期。针对的是 webpack。
2. **compilation 对象只代表一次新的编译**，只要项目文件有改动，compilation 就会被重新创建。针对的是随时可变的项目文件。
3. **如果把 compiler 算作是总控制台，那么 compilation 则专注于编译处理这件事上**。

#### Compiler，编译器，[compiler 钩子](https://webpack.docschina.org/api/compiler-hooks/)

1. Compiler 模块是 webpack 的主要引擎，它通过 CLI 或者 Node API 传递的**所有选项**创建出一个 compilation 实例。
2. 它扩展（extends）自 Tapable 类，**用来注册和调用插件**。 **大多数面向用户的插件会首先在 Compiler 上注册**。
3. 具体就是**依次调用插件的 apply 方法**，并将 compiler 对象 (包含 webpack 的各种配置信息) 传进去供 plugin 使用，**compiler 包含整个构建流程的全部钩子，通过它可以把控整个 webpack 构建周期**。
4. 在运行期间 compiler **会根据 webpack 不同阶段触发的各种事件钩子**，执行插件附加/绑定在 hook 上的函数。
5. **compiler 只是负责维持生命周期运行的功能**，所有的加载、打包和写入工作，都被委托到注册过的插件上了。
6. webpack 使用 webpackOptionsDefaulter 和 webpackOptionsApply 来配置 Compiler 实例以及所有内置插件。
7. Compiler 类实例化并注册 plugins 后，**若 webpack 函数接收了回调 callback，会执行 compiler.run()方法**，webpack 即刻开启编译之旅。如果未指定 callback 回调，则需要用户自己调用 run 方法来启动编译。
8. **webpack 从执行到结束，Compiler 只会实例化一次**。生成的 compiler 对象记录了 webpack 当前运行环境的完整的信息，该对象是全局唯一的，**插件可以通过它获取到 webpack config 信息，如 entry、output、loaders 等配置**。
   1. 这里的插件的 config 信息，会合并插件初始化的时候的参数；
9. 在 compiler 类中，提供了三种类型的内置解析器：
   1. normal: 通过绝对或相对路径解析模块。
   2. context: 在给定的上下文中解析模块。
   3. loader: 解析 webpack loader。
   4. **请注意，resolve 配置会影响 normal 解析器和 context 解析器**，**而“ resolveLoader 用于修改 loader 解析器**。

##### 具体的 compiler 钩子

1. beforeRun，读取配置文件，准备启动；
   1. beforeRun 在 webpack 开始读取配置之前，该钩子将被调用；
   2. 初始化参数 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
   3. 这个 async 钩子，在这个钩子中绑定了读取文件的对象。
      1. `webpack --hot -w` => `{ hot: true, profile: false, watch: true,}`;
   4. config 的合并与插件加载；
      1. webpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中，并加载用户配置在 webpack.config.js 的 plugins 。
2. run，在编译之前有缓存，则启用缓存；
3. watchRun，在使用 webpack-dev-server 进行开发时，该钩子将被调用；
4. beforeCompile，开始编译前的准备，创建的 ModuleFactory，创建 Compilation，并绑定 ModuleFactory 到 Compilation 上。
   1. 同时处理一些不需要编译的模块，比如 ExternalModule（远程模块）和 DllModule（第三方模块）。
5. compile，编译了，这里的编译只是处理配置文件，生成基础的 compilation；
   1. 开始编译 用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；
6. seal 封装构建结果；
7. make，从 Compilation 的 addEntry 函数，开始构建模块；
   1. 这个钩子就是正式启动编译了，所以这个钩子执行完毕就意味这编译结束了，可以进行封装 seal 了。
8. afterCompile，编译结束了；
9. shouldEmit，获取 compilation 发来的电报，确定编译时候成功，是否可以开始输出了。
10. emit，输出文件了；
11. afterEmit，输出完毕；
12. done，无论成功与否，一切已尘埃落定。
13. assetEmitted 生命周期钩子是在所有资源（如 JavaScript、CSS、图片等）都已经生成到输出目录中后，即 webpack 打包完毕后触发的。
14. normalModuleFactory：NormalModuleFactory 创建之后调用`compiler.hooks.normalModuleFactory`:
    1. 回调参数：normalModuleFactory；
    2. Compiler 使用 NormalModuleFactory 模块生成各类模块。从入口点开始，此模块会分解每个请求，解析文件内容以查找进一步的请求，然后通过分解所有请求以及解析新的文件来爬取全部文件。在最后阶段，每个依赖项都会成为一个模块实例。
    3. compiler.hooks.normalModuleFactory.tap，这里是可以获取到 ast 的结果的；

##### compiler.hooks.normalModuleFactory 与 compiler.hooks.emit 的区别

1. Compiler.hooks.normalModuleFactory 钩子**在 webpack 编译过程中的"Module"创建阶段被调用**。**在这个阶段，webpack 已经解析了模块的源代码，并将其转换为抽象语法树（AST）**。但是，webpack 还没有将该模块的代码实际编译为 JavaScript 代码。**通过在 Compiler.hooks.normalModuleFactory 钩子中添加自定义逻辑，您可以在 webpack 编译过程中改变模块的行为，例如添加自定义代码、修改模块的依赖关系、注入自定义函数等。**
2. 相比之下，**Compiler.hooks.emit 钩子在 webpack 编译过程的后期被调用。**在这个阶段，webpack 已经将所有的模块编译为 JavaScript 代码，并将它们合并到一个或多个文件中。
   1. 通过在 Compiler.hooks.emit 钩子中添加自定义逻辑，您可以在 webpack 编译过程中改变输出文件的行为，例如添加自定义代码、修改输出文件的路径等。

总的来说，**Compiler.hooks.normalModuleFactory 钩子更适合用于改变模块的行为**，而 Compiler.hooks.emit 钩子更适合用于改变输出文件的行为。您可以根据具体需求选择使用哪个钩子。

#### Compilation 编译对象，[compilation 钩子](https://webpack.docschina.org/api/compilation-hooks/)

如果说 Compiler 是流程，那么 Compilation 就是编译主场了。也就是源代码经过他加工之后才得到了升华变成了规规矩矩的模样。

Compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 Compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息，简单来讲就是把本次打包编译的内容存到内存里。Compilation 对象也提供了插件需要自定义功能的回调，以供插件做自定义处理时选择使用拓展。

##### Compilation 具体的钩子

`Compilation` 对象具有许多可用于监听和扩展构建过程的钩子（hooks）。以下是一些常见的 `Compilation` 钩子：

1. buildModule：在构建模块（Module）时触发，可以用于监听和修改模块的构建过程。
2. succeedModule：在成功构建模块后触发，可以用于处理成功构建模块的逻辑。
3. failedModule：在构建模块失败时触发，可用于处理构建失败的模块。
4. finishModules：在所有模块构建完成后触发，可以执行一些收尾工作。
5. seal：在构建过程封存前触发，允许在最终资源生成之前进行一些操作。
6. optimize：在资源优化过程开始前触发，可以用于自定义资源优化逻辑。
7. optimizeAssets：在资源优化过程中触发，可以监听和修改资源的优化过程。
8. optimizeChunkAssets：在块资源优化过程中触发，可用于自定义块资源的优化逻辑。
9. optimizeTree：在资源树优化过程中触发，允许修改资源树的优化逻辑。
10. afterOptimizeTree：在资源树优化完成后触发，可用于处理优化完成后的资源树。
11. beforeHash：在计算输出文件的哈希之前触发，可以监听和修改哈希生成的逻辑。
12. afterHash：在输出文件哈希计算完成后触发，可用于处理生成的哈希值。
13. beforeModuleAssets：在生成模块资源之前触发，可用于在模块资源生成前执行一些操作。
14. moduleAsset：在生成模块资源时触发，可监听和修改模块资源的生成。
15. processAssets：在生成资源（如 JavaScript 文件、CSS 文件等）时触发，可以监听和修改资源的生成。

这些钩子允许开发者在 webpack 构建过程中的不同阶段执行自定义操作，以满足特定的需求或优化构建结果。插件可以通过监听这些钩子来扩展 webpack 的功能，执行各种自定义逻辑，如资源优化、哈希生成、资源生成等。
