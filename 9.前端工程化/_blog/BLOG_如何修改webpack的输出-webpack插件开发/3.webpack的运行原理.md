## webpack 的基本原理

### webpack 的生命周期

Webpack 的生命周期是指 Webpack **在执行其构建任务时所经历的一系列阶段**。这些生命周期钩子来帮助开发者在构建项目时进行定制化处理。这些阶段包括：

1. 初始化阶段（ Initialization Phase ）：Webpack 在这个阶段中会解析配置文件，并初始化一些全局变量和模块。
   1. 这里就是整合所有的配置信息的阶段，这些全局、插件、babel 的配置信息会被整合到一起，给后续使用；
2. 解析阶段（ Parse Phase ）：Webpack 在这个阶段中会**解析所有的输入文件**，包括 JavaScript、CSS、图像等。它会将这些文件解析成抽象语法树（AST），以便进行进一步的处理。
   1. 这里其实就是 bebel 处理的阶段，这里的资源在 bebel 处理之后都是一团一团的代码块；
   2. 这里的 ast 可能还需要对这里的代码块进行处理，继续解析成 ast；
3. 变换阶段（ Transform Phase ）：Webpack 在这个阶段中会应用一些变换，**例如代码压缩、语法转换等**。这些变换是通过插件实现的，Webpack 会在这个阶段中调用相应的插件来执行这些变换。
   1. 插件的工作阶段；
4. 代码分离阶段（ Code Splitting Phase ）：如果配置了**代码分离**，Webpack 会在这个阶段中**将大型的 JavaScript 文件分割成多个较小的文件，以便在浏览器中按需加载**。
   1. 按需加载，这里肯定是对 ast 进行了解析的，然后判断依赖，分割代码等操作；
5. 生成阶段（ Generate Phase ）：Webpack 在这个阶段中会根据配置文件中的规则，**生成最终的输出文件**。这些文件可以是 JavaScript 文件、CSS 文件、图像文件等。
6. 加载阶段（ Load Phase ）：Webpack 在这个阶段中会加载生成的输出文件，并将它们注入到浏览器中。
   1. dev 模式的热更新；

这些阶段是 Webpack 构建过程的核心，它们共同协作以完成 Webpack 的构建任务。了解这些阶段可以帮助你更好地理解 Webpack 的工作原理，并更好地使用它来构建你的项目。

研究 webpack 的生命周期，有助于理解 webpack 的原理。

### webpack 的生命周期钩子

最主要的两个内容 Compiler 和 Compilation，他们都是基于 Tapable 类的。

Webpack 的事件流机制应用了观察者模式，和 Node.js 中的 EventEmitter 非常相似。 Compiler 和 Compilation 都继承自 Tapable，可以直接在 Compiler 和 Compilation 对象上广播和监听事件。

#### Tapable 类

1. 它是一个管理钩子事件监听与触发的小型库，**export 了许多 Hook 类**(hook 构造函数)，如 SyncHook、SyncBailHook 等，可以用来为插件创建 hooks。
2. 整体类似发布订阅模式。
   1. tap: (name: string | Tap, fn: (context?, ...args) => Result) => void
      1. 同步 hook 只能使用 tap 方法；
   2. tapAsync: (name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void
      1. 当我们用 tapAsync 方法来绑定插件时，*必须*调用函数的最后一个参数 callback 指定的回调函数。
   3. tapPromise: (name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void
      1. 当我们用 tapPromise 方法来绑定插件时，*必须*返回一个 pormise ，异步任务完成后 resolve 。

```ts
interface Tap {
  name: string;
  type: string;
  fn: Function;
  stage: number;
  context: boolean;
  before?: string | Array;
}
```

##### 同步与异步 hook

1. 同步 hook 只能使用 tap 方法；
2. 而异步 hook 除了 tapAsync 和 tapPromise 这些异步方法，也支持用 tap 方法让 hook 以同步方式运行。
   1. **当我们使用 tapPromise method 来访问插件时，则需要返回一个 promise**，它可以在异步任务完成时解决。
3. **我们可以有多种方式 hook 到 compiler 中**，hook 将编译一个方法，可以让各种插件都以最合适有效的方式去运行。
4. 创建钩子的方法：`const hook = new SyncHook(["arg1", "arg2", "arg3"])`；
5. 在 webpack 运行特定阶段(比如 compiler.run 和 compile)通过 call、callAsync、promise 调用这些 hook，**声明注册在这个 hook 上的插件 (内的方法) 触发的时机**。类实似于发布-订阅模式中的**发布事件**。
6. 插件通过 tap、tapAsync 等方法订阅 Compiler 或 Compilation 实例的 hook，方法内可以调用 api 进行一些处理。
7. 也就是说这里的 hook**通过 tap 相关方法进行订阅**，**发布是通过 apply 或者 call 来进行**；
   1. plugin.call(compiler, compiler);
   2. plugin.apply(compiler);

#### Compiler 和 Compilation 的关系

1. **compiler 对象代表的是构建过程中不变的 webpack 环境**，整个 webpack 从启动到关闭的生命周期。针对的是 webpack。
2. **compilation 对象只代表一次新的编译**，只要项目文件有改动，compilation 就会被重新创建。针对的是随时可变的项目文件。
3. **如果把 compiler 算作是总控制台，那么 compilation 则专注于编译处理这件事上**。

#### Compiler 钩子，[compiler 钩子](https://webpack.docschina.org/api/compiler-hooks/)

1. Compiler 模块是 webpack 的主要引擎，它通过 CLI 或者 Node API 传递的**所有选项**创建出一个 compilation 实例。
2. 它扩展（extends）自 Tapable 类，**用来注册和调用插件**。 **大多数面向用户的插件会首先在 Compiler 上注册**。
3. 具体就是**依次调用插件的 apply 方法**，并将 compiler 对象 (包含 webpack 的各种配置信息) 传进去供 plugin 使用，**compiler 包含整个构建流程的全部钩子，通过它可以把控整个 webpack 构建周期**。
4. 在运行期间 compiler **会根据 webpack 不同阶段触发的各种事件钩子**，执行插件附加/绑定在 hook 上的函数。
5. **compiler 只是负责维持生命周期运行的功能**，所有的加载、打包和写入工作，都被委托到注册过的插件上了。
6. webpack 使用 WebpackOptionsDefaulter 和 WebpackOptionsApply 来配置 Compiler 实例以及所有内置插件。
7. Compiler 类实例化并注册 plugins 后，**若 webpack 函数接收了回调 callback，会执行 compiler.run()方法**，webpack 即刻开启编译之旅。如果未指定 callback 回调，则需要用户自己调用 run 方法来启动编译。
8. **webpack 从执行到结束，Compiler 只会实例化一次**。生成的 compiler 对象记录了 webpack 当前运行环境的完整的信息，该对象是全局唯一的，**插件可以通过它获取到 webpack config 信息，如 entry、output、loaders 等配置**。
   1. 这里的插件的 config 信息，会合并插件初始化的时候的参数；
9. 在 compiler 类中，提供了三种类型的内置解析器：
   1. normal: 通过绝对或相对路径解析模块。
   2. context: 在给定的上下文中解析模块。
   3. loader: 解析 webpack loader。
   4. **请注意，resolve 配置会影响 normal 解析器和 context 解析器**，**而“ resolveLoader 用于修改 loader 解析器**。

##### 具体的 compiler 钩子

1. beforeRun，读取配置文件，准备启动；
   1. beforeRun 在 Webpack 开始读取配置之前，该钩子将被调用；
   2. 初始化参数 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
   3. 这个 async 钩子，在这个钩子中绑定了读取文件的对象。
      1. `webpack --hot -w` => `{ hot: true, profile: false, watch: true,}`;
   4. config 的合并与插件加载；
      1. webpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中，并加载用户配置在 webpack.config.js 的 plugins 。
2. run，在编译之前有缓存，则启用缓存；
3. watchRun 在使用 webpack-dev-server 进行开发时，该钩子将被调用；
4. beforeCompile，开始编译前的准备，创建的 ModuleFactory，创建 Compilation，并绑定 ModuleFactory 到 Compilation 上。
   1. 同时处理一些不需要编译的模块，比如 ExternalModule（远程模块）和 DllModule（第三方模块）。
5. compile，编译了，这里的编译只是处理配置文件，生成基础的 compilation；
   1. 开始编译 用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；
6. seal 封装构建结果；
7. make，从 Compilation 的 addEntry 函数，开始构建模块；
   1. 这个钩子就是正式启动编译了，所以这个钩子执行完毕就意味这编译结束了，可以进行封装 seal 了。
8. afterCompile，编译结束了；
9. shouldEmit，获取 compilation 发来的电报，确定编译时候成功，是否可以开始输出了。
10. emit，输出文件了；
11. afterEmit，输出完毕；
12. done，无论成功与否，一切已尘埃落定。
13. assetEmitted 生命周期钩子是在所有资源（如 JavaScript、CSS、图片等）都已经生成到输出目录中后，即 webpack 打包完毕后触发的。
14. normalModuleFactory：NormalModuleFactory 创建之后调用`compiler.hooks.normalModuleFactory`:
    1. 回调参数：normalModuleFactory；
    2. Compiler 使用 NormalModuleFactory 模块生成各类模块。从入口点开始，此模块会分解每个请求，解析文件内容以查找进一步的请求，然后通过分解所有请求以及解析新的文件来爬取全部文件。在最后阶段，每个依赖项都会成为一个模块实例。
    3. compiler.hooks.normalModuleFactory.tap，这里是可以获取到 ast 的结果的；

#### compiler.hooks.normalModuleFactory 与 compiler.hooks.emit 的区别

1. Compiler.hooks.normalModuleFactory 钩子**在 Webpack 编译过程中的"Module"创建阶段被调用**。**在这个阶段，Webpack 已经解析了模块的源代码，并将其转换为抽象语法树（AST）**。但是，Webpack 还没有将该模块的代码实际编译为 JavaScript 代码。**通过在 Compiler.hooks.normalModuleFactory 钩子中添加自定义逻辑，您可以在 Webpack 编译过程中改变模块的行为，例如添加自定义代码、修改模块的依赖关系、注入自定义函数等。**
2. 相比之下，**Compiler.hooks.emit 钩子在 Webpack 编译过程的后期被调用。**在这个阶段，Webpack 已经将所有的模块编译为 JavaScript 代码，并将它们合并到一个或多个文件中。
   1. 通过在 Compiler.hooks.emit 钩子中添加自定义逻辑，您可以在 Webpack 编译过程中改变输出文件的行为，例如添加自定义代码、修改输出文件的路径等。

总的来说，**Compiler.hooks.normalModuleFactory 钩子更适合用于改变模块的行为**，而 Compiler.hooks.emit 钩子更适合用于改变输出文件的行为。您可以根据具体需求选择使用哪个钩子。

#### 重要的属性，[compilation-object](https://www.webpackjs.com/api/compilation-object/#compilation-object-methods)

编译（compilation）通常是指构建过程的单个执行实例，其中包括从源代码到目标代码的所有操作。在大多数情况下，编译代表一次构建任务，可能包括多个模块的处理。编译可以具有不同的属性和状态，如编译错误、警告、优化级别等。

在编译器的回调函数中，"compilation" 属性通常表示整个编译任务。

1. 模块（modules）
   1. 而 "modules" 属性包含了构建过程中的所有模块（也通常以对象的形式表示）。
   2. 通常指构建过程中的**源代码文件或代码单元**，它们可以是 JavaScript 模块、CSS 文件、图像文件等。模块通常是构建过程的输入，它们可以相互依赖并被打包到不同的代码块中。在前端开发中，模块通常使用 ES6 模块系统或 CommonJS 模块系统来组织和导入/导出代码。
2. chunks（代码块）
   1. "chunks" 属性包含了**构建生成的不同代码块**（通常以对象的形式表示）。
   2. 代码块（chunks）通常**是指构建过程中生成的独立的代码文件或资源文件**，这些文件可以在浏览器端或服务器端使用。
   3. 在前端构建中，代码块通常对应于不同的页面或入口点，每个代码块可能包含了与特定页面或功能相关的 JavaScript、CSS 和其他资源。在后端构建中，代码块可以代表不同的模块或库。

#### Compilation 的钩子，compilation / [compilation 钩子](https://webpack.docschina.org/api/compilation-hooks/)

如果说 Compiler 是流程，那么 Compilation 就是编译主场了。也就是源代码经过他加工之后才得到了升华变成了规规矩矩的模样。

Compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 Compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息，简单来讲就是把本次打包编译的内容存到内存里。Compilation 对象也提供了插件需要自定义功能的回调，以供插件做自定义处理时选择使用拓展。
简单来说,Compilation 的职责就是构建模块和 Chunk，并利用插件优化构建过程。
和 Compiler 用法相同，钩子类型不同，也可以在某些钩子上访问 tapAsync 和 tapPromise。

Compilation 是 Compiler 用来创建一次新的编译过程的模块。一个 Compilation 实例可以访问所有模块和它们的依赖。在一次编译阶段，模块被加载、封装、优化、分块、散列和还原。
Compilation 也继承了 Tapabl 并提供了很多生命周期钩子。

1. Compilation 模块会被 Compiler 用来创建新的 compilation 对象（或新的 build 对象）。 compilation 实例能够访问所有的模块和它们的依赖（大部分是循环依赖）。
2. **在编译阶段，模块会被加载(load)、封存(seal)、优化(optimize)、 分块(chunk)、哈希(hash)和重新创建(restore)**。
3. Compilation 类(./lib/Compilation.js)：扩展自 Tapable，也提供了很多关键点回调供插件做自定义处理时选择使用拓展。
4. 一个 compilation 对象**代表了一次单一的版本构建和生成资源**，它储存了当前的模块资源、编译生成的资源、变化的文件、以及被跟踪依赖的状态信息。
5. 简单来说，Compilation 的职责就是对所有 require 图(graph)中对象的**字面上的编译**，**构建 module 和 chunk**，并利用插件优化构建过程，同时把本次打包编译的内容全存到内存里。
6. **compilation 编译可以多次执行**，**如在 watch 模式下启动 webpack，每次监测到源文件发生变化，都会重新实例化一个 compilation 对象**，从而生成一组新的编译资源。这个对象可以访问所有的模块和它们的依赖（大部分是循环依赖）。
7. [compilation 对象方法](https://webpack.docschina.org/api/compilation-object/#compilation-object-methods)。
   1. getStats；
   2. addModule；
   3. addEntry；
   4. finish；

##### Compilation 具体的钩子

1. buildModule SyncHook 在模块开始编译之前触发，可以用于修改模块
2. succeedModule SyncHook 当一个模块被成功编译，会执行这个钩子
3. finishModules AsyncSeriesHook 当所有模块都编译成功后被调用
4. seal SyncHook 当一次 compilation 停止接收新模块时触发
5. optimizeDependencies SyncBailHook 在依赖优化的开始执行
6. optimize SyncHook 在优化阶段的开始执行
7. optimizeModules SyncBailHook 在模块优化阶段开始时执行，插件可以在这个钩子里执行对模块的优化，回调参数：modules
8. optimizeChunks SyncBailHook 在代码块优化阶段开始时执行，插件可以在这个钩子里执行对代码块的优化，回调参数：chunks
9. optimizeChunkAssets AsyncSeriesHook 优化任何代码块资源，这些资源存放在
10. compilation.assets 上。一个 chunk 有一个 files 属性，它指向由一个 chunk 创建的所有文件。任何额外的 chunk 资源都存放在 compilation
11. additionalChunkAssets 上。回调参数：chunks
12. optimizeAssets AsyncSeriesHook 优化所有存放在 compilation.assets 的所有资源。回调参数：assets

### webpack 运行的基本流程

### webpack 的运行原理总结

基本上，Webpack 的工作原理可以概括为：从入口文件开始，分析依赖关系，通过加载器处理不同类型的模块，通过插件执行各种任务，最终输出打包后的文件。Webpack 的强大之处在于其高度可配置性和可扩展性，允许开发者根据项目需求定制构建流程，从而满足不同项目的需求。
