## Webpack生命周期及其实现过程

Webpack提供了许多生命周期钩子来帮助开发者在构建项目时进行定制化处理。

Webpack 生命周期主要分为以下 11 个阶段。这里需要注意区分dev和build模式。

<!-- !这里可以放几个图片 -->

### 分析一下webpack的生命周期

可以说Compiler.js这个类才是真正得控制了webpack打包的流程，如果说webpack.js所做的事是准备，那么Compiler就是撸起袖子就是干。

1. beforeRun，读取配置文件，准备启动；
   1. 这个async钩子，在这个钩子中绑定了读取文件的对象。
      1. `webpack --hot -w` => `{ hot: true, profile: false, watch: true,}`;
   2. config 的合并与插件加载；
      1. webpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中，并加载用户配置在 webpack.config.js 的 plugins 。
2. run，在编译之前有缓存，则启用缓存；
3. beforeCompile，开始编译前的准备，创建的ModuleFactory，创建Compilation，并绑定ModuleFactory到Compilation上。
   1. 同时处理一些不需要编译的模块，比如ExternalModule（远程模块）和DllModule（第三方模块）。
4. compile，编译了，这里的编译只是处理配置文件，生成基础的compilation；
5. seal 封装构建结果；
6. make，从Compilation的addEntry函数，开始构建模块；
   1. 这个钩子就是正式启动编译了，所以这个钩子执行完毕就意味这编译结束了，可以进行封装seal了。
7. afterCompile，编译结束了；
8. shouldEmit，获取compilation发来的电报，确定编译时候成功，是否可以开始输出了。
9. emit，输出文件了；
10. afterEmit，输出完毕；
11. done，无论成功与否，一切已尘埃落定。

### 生命周期

Webpack 的生命周期是指 Webpack 在执行其构建任务时所经历的一系列阶段。这些阶段包括：

1. 初始化阶段（ Initialization Phase ）：Webpack 在这个阶段中会解析配置文件，并初始化一些全局变量和模块。
   1. 这里就是整合所有的配置信息的阶段，这些全局、插件、babel的配置信息会被整合到一起，给后续使用；
2. 解析阶段（ Parse Phase ）：Webpack 在这个阶段中会**解析所有的输入文件**，包括 JavaScript、CSS、图像等。它会将这些文件解析成抽象语法树（AST），以便进行进一步的处理。
   1. 这里其实就是bebel处理的阶段，这里的资源在bebel处理之后都是一团一团的代码块；
   2. 这里的ast可能还需要对这里的代码块进行处理，继续解析成ast；
3. 变换阶段（ Transform Phase ）：Webpack 在这个阶段中会应用一些变换，**例如代码压缩、语法转换等**。这些变换是通过插件实现的，Webpack 会在这个阶段中调用相应的插件来执行这些变换。
   1. 插件的工作阶段；
4. 代码分离阶段（ Code Splitting Phase ）：如果配置了**代码分离**，Webpack 会在这个阶段中**将大型的 JavaScript 文件分割成多个较小的文件，以便在浏览器中按需加载**。
   1. 按需加载，这里肯定是对ast进行了解析的，然后判断依赖，分割代码等操作；
5. 生成阶段（ Generate Phase ）：Webpack 在这个阶段中会根据配置文件中的规则，**生成最终的输出文件**。这些文件可以是 JavaScript 文件、CSS 文件、图像文件等。
6. 加载阶段（ Load Phase ）：Webpack 在这个阶段中会加载生成的输出文件，并将它们注入到浏览器中。
   1. dev模式的热更新；

这些阶段是 Webpack 构建过程的核心，它们共同协作以完成 Webpack 的构建任务。了解这些阶段可以帮助你更好地理解 Webpack 的工作原理，并更好地使用它来构建你的项目。

### Compiler与Compilation

如果说Compiler是流程，那么Compilation就是编译主场了。也就是源代码经过他加工之后才得到了升华变成了规规矩矩的模样。

### EntryOptionPlugin

EntryOptionPlugin是帮助我们处理入口类型的插件，他会webpack.config.js中entry的不同配置帮助我们搭配不同的EntryPlugin。通过entry配置进入的一共有3种类型，SingleEntryPlugin，MultiEntryPlugin和DynamicEntryPlugin，根据名字就能够轻易区分他们的类型。一般一个compiler只会触发一个EntryPlugin，然后在这个EntryPlugin中，会有我们构建模块的入口，也就是compilation的入口。

### other

1. beforeRun在 Webpack 开始读取配置之前，该钩子将被调用。
   1. 初始化参数 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数
2. run在 Webpack 开始编译时，该钩子将被调用。
3. **watchRun在使用 webpack-dev-server 进行开发时，该钩子将被调用**。
4. beforeCompile在 Webpack 开始编译之前，该钩子将被调用。
5. compile在 Webpack 开始编译时，该钩子将被调用。
   1. 开始编译 用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译
      1. 确定入口 根据配置中的 entry 找出所有的入口文件
6. thisCompilation在创建新的 Compilation 对象时，该钩子将被调用。
7. compilation在编译时，每当 Webpack 生成一个新的 Compilation 对象时，该钩子将被调用。
8. emit在生成资源之前，该钩子将被调用。
9. afterEmit在生成资源之后，该钩子将被调用。
10. done在 Webpack 编译完成时，该钩子将被调用。
11. assetEmitted 生命周期钩子是在所有资源（如 JavaScript、CSS、图片等）都已经生成到输出目录中后，即 webpack 打包完毕后触发的。

## [JavascriptParser Hooks](https://webpack.docschina.org/api/parser/)

[Webpack JavaScriptParser Hooks 使用小结](https://juejin.cn/post/7117837829165547556)

1. Webpack 在将代码转换为 AST 的同时为我们提供了 JavaScriptParser 钩子函数，以便开发者能够分析模块依赖，并根据自己的需求替换或添加依赖。

### MetaProperty && 自由变量

1. 在 JavaScript 中，如果某个作用域中使用了变量 a，但变量 a 并未在该作用域中声明，那么变量 a 即为自由变量。
2. MetaProperty：如果看 ESTree Spec MetaProperty 的解释，相信大家直接会晕掉，通过翻看 acorn 的实现可知，MetaProperty 指的就是 new.target 和 import.meta 属性；
   1. new.target：该属性常用来检测函数是否是通过 new 运行符被调用的，在通过 new 运算符初始化的函数中，new.target 返回一个指向该函数的引用，在普通的函数调用中，new.target 为 undefined。
   2. import.meta：通过 import.meta 可获得当前模块的元信息，该属性只能在模块内部使用，常用属性有；
      1. import.meta.url：在浏览器环境下返回模块所在的 URL 路径，在 Node.js 环境下返回模块所在的本地路径（以 file:/ 开头）；
      2. import.meta.scriptElement：仅在浏览器下可用，返回加载该模块的 <script> 元素，作用等同于 document.currentScript。

### 可通过 NormalModuleFactory 获取 JavaScriptParser 实例

上例代码清晰明了，不过多阐述，只对 for 中参数的可用值进行简短介绍：

1. javascript/auto：处理 CommonJS、AMD 及 ESModule 格式的 JavaScript 模块及其依赖；
2. javascript/dynamic：处理 CommonJS 及 AMD 格式的 JavaScript 模块及其依赖；
3. javascript/esm：处理 ESModule 格式的 JavaScript 模块及其依赖。

### 钩子列表

1. 有些钩子无需调用 for 方法）；
2. evaluateTypeof：将对自由变量（或其属性）、new.target（或其属性）、import.meta（或其属性）执行 typeof 操作赋值给某一变量（或作为 if 语句的判断条件）时触发；
3. statement：通用钩子，每解析一个语句调用一次；

## dependencyTemplates

Dependency Templates 是 Webpack 4 中引入的一个新特性，它允许您使用 JavaScript 代码来定义 Webpack 构建过程中的依赖关系。 Dependency Templates 可以帮助您更灵活地处理依赖关系，并提高构建速度。

Dependency Templates 是通过 webpack.DependencyTemplates 配置项来配置的。您可以使用 JavaScript 代码定义一个或多个 Dependency Templates，并将它们添加到 webpack.config.js 文件中。
