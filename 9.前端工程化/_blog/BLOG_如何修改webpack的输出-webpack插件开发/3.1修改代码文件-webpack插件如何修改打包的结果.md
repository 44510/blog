## 插件开发-修改源文件 / webpack 插件如何修改打包的结果

<!-- !关键的步骤，目前可以测试loader修改文件以及添加一些代码，但是在其中直接通过ast修改还是没法实现 -->

可以这样理解，修改文件都需要修改 assets。

并且在经过 loader 之后，代码都是精 webpack 包裹的，所以很难直接修改源码了，获取到的 modules 的结果确实是原始代码，但是修改这些没什么作用。后续拿到的 ast 应该也是一样的问题。

？？？
是不是因为修改 ast 的结果不对，导致会被重置回去？

**一个方向**

直接修改 assets 中的源码，对得到的内容进行处理。先拿到字符串，然后修改后，重新放回去。

[webpack 插件开发及修改源码的几种方式](https://blog.csdn.net/laifawailian/article/details/120287891)

Compiler 代表着 webpack 从启动到关闭的整个生命周期，**而 Compilation 只代表来一次编译，而修改源码的时机正好需要在编译的过程中修改**。

1. **通过 optimizeChunkAssets 的钩子可以拿到所有的 chunks 信息，针对具体的 chunks 可以修改对应的源码**。
   1. DeprecationWarning: optimizeChunkAssets is deprecated (use Compilation.hooks.processAssets instead and use one of Compilation.PROCESS*ASSETS_STAGE*\* as stage option)。
   2. 插件提供了丰富的生命周期，在修改源码过程中也要特别要注意插件的生命周期带来的影响，比如**上述在 optimizeChunkAssets 阶段，这个阶段拿到的 chunk 资源已经完成各种 Loader 的处理，这个时候如果新增源码内容是 ES6，将不会再被转化**。
   3. **optimizeChunkAssets 阶段代码已经被打包过了**，我觉得不能称之为 【源码】。
   4. optimizeChunkAssets 钩子中修改源码可能引起问题，因为在此之前 hash 值已经生成。
2. 结合 ast 在 loader 中修改，这时的源码还没被 webpack 处理，可以增加其他依赖。
   1. 在 webpack 中通过插件修改，修改时机尽量的提前，可以在 Chunk 生成之前。
   2. uglifyjs 修改代码的时机，是在 optimizeChunkAssets 阶段。
   3. webpack 中使用 acorn 处理源码，主要目的是分析依赖处理依赖；如果需要添加依赖用 loader 处理添加，第二种方式可以直接处理源码，生成 Chunk 后 webpack 会在源码上添加其他的东西。
3. 通过生命周期拿到当前代码的 ast 进行修改；

### 结合 ast 在 loader 中修改，这时的源码还没被 webpack 处理，可以增加其他依赖

### 实现一个防止代码被调试的插件。 思路，生产环境代码中注入 debuger

### DeprecationWarning: Compilation.assets will be frozen in future, all modifications are deprecated

BREAKING CHANGE: No more changes should happen to Compilation.assets after sealing the Compilation.

根据提示可知，我们需要使用 Compilation 中的 processAssets hook 来对资源进行再处理。

### 修改代码的方式

```js
// 1. 在前后添加文件；

// 方法1，直接拼接数据
let source = compilation.assets[filename].source();
source = '/*这是我通过webpack plugin 在js文件中插入的一行代码*/\n' + source;

// 方法2，通过操作ast进行添加
```

## compiler.hooks.normalModuleFactory.tap，这里是可以获取到 ast 的结果的

Compiler.hooks.normalModuleFactory 是 Webpack 中的一个钩子，它允许您在 Webpack 编译过程的特定阶段执行自定义逻辑。

**在 Webpack 中，每个模块都被表示为一个"Module"对象**。**Webpack 通过一个"ModuleFactory"来创建这些"Module"对象**。Compiler.hooks.normalModuleFactory 钩子允许您在这个"ModuleFactory"中添加自定义逻辑，以影响 Webpack 编译过程中的模块创建过程。

Compiler.hooks.normalModuleFactory 钩子在 Webpack 编译过程中的"Module"创建阶段被调用。**在这个阶段，Webpack 已经解析了模块的源代码，并将其转换为抽象语法树（AST）**。**但是，Webpack 还没有将该模块的代码实际编译为 JavaScript 代码**。

通过在 Compiler.hooks.normalModuleFactory 钩子中**添加自定义逻辑，您可以在 Webpack 编译过程中改变模块的行为，例如添加自定义代码、修改模块的依赖关系、注入自定义函数等**。

### 怎么将修改的结果印象到整体里边 / normalModuleFactory 如何修改 ast

Compiler.hooks.normalModuleFactory 是 Webpack 中的一个钩子，它允许您在 Webpack 编译过程的特定阶段执行自定义逻辑。在这个钩子中，您可以修改抽象语法树（AST）。
**要修改 AST，您可以使用 Webpack 的 normalModuleFactory 钩子的 factory 方法。这个方法接受一个函数作为参数，该函数接受一个 Compiler 对象和一个 Module 对象作为参数。**在这个函数中，您可以使用 Compiler 对象的 parser 方法获取该模块的 AST，并进行修改。
下面是一个示例，演示如何使用 Compiler.hooks.normalModuleFactory 钩子修改 AST：

```js
compiler.hooks.normalModuleFactory.tap('MyPlugin', function (Compiler, module) {
  var tree = Compiler.parser(module.src);
  // 修改 tree
  module.src = Compiler.outputOptions.sourceMap ? tree.toSource() : tree.toESM();
});
```

在上面的示例中，我们首先使用 Compiler.parser 方法获取该模块的 AST。然后，我们可以根据需要修改该 AST。最后，**我们使用 Compiler.outputOptions.sourceMap 选项来决定是否生成源代码映射（source map）**。**如果生成源代码映射，我们将修改后的 AST 转换为源代码，否则我们将其转换为 ECMAScript 模块（ESM）格式**。
请注意，修改 AST 可能会影响 Webpack 的编译结果，因此请谨慎使用。**如果您需要对 AST 进行大量修改，建议编写自己的 Webpack 插件来实现**。

## compiler.hooks.emit.tap('AssetsReplacePlugin'，这里是可以修改资源的结果的，一般通过返回 source()方法的结果来修改

<!-- !重要 -->

### compiler.hooks.normalModuleFactory 与 compiler.hooks.emit 的区别

1. Compiler.hooks.normalModuleFactory 钩子**在 Webpack 编译过程中的"Module"创建阶段被调用**。**在这个阶段，Webpack 已经解析了模块的源代码，并将其转换为抽象语法树（AST）**。但是，Webpack 还没有将该模块的代码实际编译为 JavaScript 代码。**通过在 Compiler.hooks.normalModuleFactory 钩子中添加自定义逻辑，您可以在 Webpack 编译过程中改变模块的行为，例如添加自定义代码、修改模块的依赖关系、注入自定义函数等。**
2. 相比之下，**Compiler.hooks.emit 钩子在 Webpack 编译过程的后期被调用。**在这个阶段，Webpack 已经将所有的模块编译为 JavaScript 代码，并将它们合并到一个或多个文件中。
   1. 通过在 Compiler.hooks.emit 钩子中添加自定义逻辑，您可以在 Webpack 编译过程中改变输出文件的行为，例如添加自定义代码、修改输出文件的路径等。

总的来说，**Compiler.hooks.normalModuleFactory 钩子更适合用于改变模块的行为**，而 Compiler.hooks.emit 钩子更适合用于改变输出文件的行为。您可以根据具体需求选择使用哪个钩子。

#### javascript/auto、javascript/esm、javascript/dynamic 的区别

1. javascript/auto 默认。包括 esm/cjs/amd 写法的文件模块
2. javascript/esm 以 .mjs 结尾的文件模块
3. javascript/dynamic 不确定性的 js 模块，比如 externals 里配置的

## 可以修改 ast 的点

<!-- !重要 -->

1. loader. 自己写 loader 返回字符串, 或者通过 babel 插件。
   1. 在代码处理前处理，当然是没问题的；
2. webpack codegen；
   1. emit 阶段，是 ast 生成 code 的阶段；
3. webpack optimize；

webpack parse 阶段明明能直接获取 ast, 缺不能修改, 因为 webpack 在调用钩子的前后会记录/恢复状态。

## 在 compilation.assets 直接修改文件

```js
// emit：所有文件的编译及转化都已经完成，包含了最终输出的资源，我们可以在传入事件回调的compilation.assets上拿到所需数据，其中包括即将输出的资源、代码块Chunk等等信息。

// 修改或添加资源
compilation.assets['new-file.js'] = {
  source() {
    return 'var a=1';
  },
  size() {
    return this.source().length;
  },
};

// afterEmit：文件已经写入磁盘完成

// parse阶段，文件转为ast树解析处import、export等；
```
