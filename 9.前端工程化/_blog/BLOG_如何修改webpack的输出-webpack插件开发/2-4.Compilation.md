## compilation / [compilation 钩子](https://webpack.docschina.org/api/compilation-hooks/)

1. Compilation 模块会被 Compiler 用来创建新的 compilation 对象（或新的 build 对象）。
2. **compilation 实例能够访问所有的模块和它们的依赖（大部分是循环依赖）**。
3. **在编译阶段，模块会被加载(load)、封存(seal)、优化(optimize)、 分块(chunk)、哈希(hash)和重新创建(restore)**。
4. Compilation 类(./lib/Compilation.js)：扩展自 Tapable，也提供了很多关键点回调供插件做自定义处理时选择使用拓展。
5. 一个 compilation 对象**代表了一次单一的版本构建和生成资源**，它储存了当前的模块资源、编译生成的资源、变化的文件、以及被跟踪依赖的状态信息。
6. 简单来说，Compilation 的职责就是对所有 require 图(graph)中对象的**字面上的编译**，**构建 module 和 chunk**，并利用插件优化构建过程，同时把本次打包编译的内容全存到内存里。
7. **compilation 编译可以多次执行**，**如在 watch 模式下启动 webpack，每次监测到源文件发生变化，都会重新实例化一个 compilation 对象**，从而生成一组新的编译资源。这个对象可以访问所有的模块和它们的依赖（大部分是循环依赖）。
8. [compilation 对象方法](https://webpack.docschina.org/api/compilation-object/#compilation-object-methods)。
   1. getStats；
   2. addModule；
   3. addEntry；
   4. finish；

### Compiler 和 Compilation 的区别

1. **compiler 对象代表的是构建过程中不变的 webpack 环境**，整个 webpack 从启动到关闭的生命周期。针对的是 webpack。
2. **compilation 对象只代表一次新的编译**，只要项目文件有改动，compilation 就会被重新创建。针对的是随时可变的项目文件。
3. **如果把 compiler 算作是总控制台，那么 compilation 则专注于编译处理这件事上**。

### 常用到的插件的 hook

1. emit：输出 asset 到 output 目录之前执行。这个钩子 不会 被复制到子编译器。
2. done.tap ：执行完成后执行这里；
3. compilation.tap：指定一个挂载到 compilation 的钩子，回调函数的参数为 compilation。

### 解析器（Resolvers）

1. 解析器是使用 enhanced-resolve 库创建的。Resolver 类 拓展了 tapable 类，并使用 tapable 来提供了一些钩子。

### ContextModuleFactory Hooks

1. Compiler 使用 ContextModuleFactory 模块从 webpack 独特的 require.context API 生成依赖关系。它会解析请求的目录，为每个文件生成请求，并依据传递来的 regExp 进行过滤。最后匹配成功的依赖关系将被传入 NormalModuleFactory。

### JavascriptParser Hooks

1. parser 实例，在 compiler 中被发现，是用来解析由 webpack 处理过的每个模块。parser 也是扩展自 tapable 的 webpack 类 并且提供多种 tapable 钩子。

### compilation / [compilation 钩子](https://webpack.docschina.org/api/compilation-hooks/)

1. Compilation 模块会被 Compiler 用来创建新的 compilation 对象（或新的 build 对象）。 compilation 实例能够访问所有的模块和它们的依赖（大部分是循环依赖）。
2. **在编译阶段，模块会被加载(load)、封存(seal)、优化(optimize)、 分块(chunk)、哈希(hash)和重新创建(restore)**。
3. Compilation 类(./lib/Compilation.js)：扩展自 Tapable，也提供了很多关键点回调供插件做自定义处理时选择使用拓展。
4. 一个 compilation 对象**代表了一次单一的版本构建和生成资源**，它储存了当前的模块资源、编译生成的资源、变化的文件、以及被跟踪依赖的状态信息。
5. 简单来说，Compilation 的职责就是对所有 require 图(graph)中对象的**字面上的编译**，**构建 module 和 chunk**，并利用插件优化构建过程，同时把本次打包编译的内容全存到内存里。
6. **compilation 编译可以多次执行**，**如在 watch 模式下启动 webpack，每次监测到源文件发生变化，都会重新实例化一个 compilation 对象**，从而生成一组新的编译资源。这个对象可以访问所有的模块和它们的依赖（大部分是循环依赖）。
7. [compilation 对象方法](https://webpack.docschina.org/api/compilation-object/#compilation-object-methods)。
   1. getStats；
   2. addModule；
   3. addEntry；
   4. finish；

### more 解释

Compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 Compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息，简单来讲就是把本次打包编译的内容存到内存里。Compilation 对象也提供了插件需要自定义功能的回调，以供插件做自定义处理时选择使用拓展。
简单来说,Compilation 的职责就是构建模块和 Chunk，并利用插件优化构建过程。
和 Compiler 用法相同，钩子类型不同，也可以在某些钩子上访问 tapAsync 和 tapPromise。

### Compiler 和 Compilation 的区别

1. **compiler 对象代表的是构建过程中不变的 webpack 环境**，整个 webpack 从启动到关闭的生命周期。针对的是 webpack。
2. **compilation 对象只代表一次新的编译**，只要项目文件有改动，compilation 就会被重新创建。针对的是随时可变的项目文件。
3. **如果把 compiler 算作是总控制台，那么 compilation 则专注于编译处理这件事上**。

### 常用到的插件的 hook

1. emit：输出 asset 到 output 目录之前执行。这个钩子 不会 被复制到子编译器。
2. done.tap ：执行完成后执行这里；
3. compilation.tap：指定一个挂载到 compilation 的钩子，回调函数的参数为 compilation。

### 解析器（Resolvers）

1. 解析器是使用 enhanced-resolve 库创建的。Resolver 类 拓展了 tapable 类，并使用 tapable 来提供了一些钩子。

### ContextModuleFactory Hooks

1. Compiler 使用 ContextModuleFactory 模块从 webpack 独特的 require.context API 生成依赖关系。它会解析请求的目录，为每个文件生成请求，并依据传递来的 regExp 进行过滤。最后匹配成功的依赖关系将被传入 NormalModuleFactory。

### JavascriptParser Hooks

1. parser 实例，在 compiler 中被发现，是用来解析由 webpack 处理过的每个模块。parser 也是扩展自 tapable 的 webpack 类 并且提供多种 tapable 钩子。

## Compilation Hooks

Compilation 是 Compiler 用来创建一次新的编译过程的模块。一个 Compilation 实例可以访问所有模块和它们的依赖。在一次编译阶段，模块被加载、封装、优化、分块、散列和还原。
Compilation 也继承了 Tapabl 并提供了很多生命周期钩子。

1. buildModule SyncHook 在模块开始编译之前触发，可以用于修改模块
2. succeedModule SyncHook 当一个模块被成功编译，会执行这个钩子
3. finishModules AsyncSeriesHook 当所有模块都编译成功后被调用
4. seal SyncHook 当一次 compilation 停止接收新模块时触发
5. optimizeDependencies SyncBailHook 在依赖优化的开始执行
6. optimize SyncHook 在优化阶段的开始执行
7. optimizeModules SyncBailHook 在模块优化阶段开始时执行，插件可以在这个钩子里执行对模块的优化，回调参数：modules
8. optimizeChunks SyncBailHook 在代码块优化阶段开始时执行，插件可以在这个钩子里执行对代码块的优化，回调参数：chunks
9. optimizeChunkAssets AsyncSeriesHook 优化任何代码块资源，这些资源存放在
10. compilation.assets 上。一个 chunk 有一个 files 属性，它指向由一个 chunk 创建的所有文件。任何额外的 chunk 资源都存放在 compilation
11. additionalChunkAssets 上。回调参数：chunks
12. optimizeAssets AsyncSeriesHook 优化所有存放在 compilation.assets 的所有资源。回调参数：assets

### compilation 常用到的钩子

1. reviveChunks：从 record 中恢复 chunk 信息。
