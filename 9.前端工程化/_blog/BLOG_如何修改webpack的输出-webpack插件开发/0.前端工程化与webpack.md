## 前端工程化

前端工程化是一种方法论和实践，旨在提高前端开发团队的效率、代码质量、可维护性，并促进协作。它涵盖了许多不同的工具、流程和最佳实践，用于优化前端开发过程的各个方面。

工欲善其事，必先利其器。前端工程化的问题从最开始的刀耕火种到后边的百花齐放，随着时间的推移与前端项目的复杂程度递增，需要学习和使用各种各样的工具来方便我们完成工作。

前端工程化涉及到很多的方面，对于一个前端来说，日常最常接触的就是项目的**项目构建和打包**了，从最开始的 `grunt`、`gulp` 到后边的 `webpack`、`vite` 等。

本文主要介绍如何个人对于 webpack 插件开发与 babel 处理 ast 的一些理解。

## webpack 介绍

webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。

**webpack 的构建过程**是通过 Compiler 控制流程，Compilation 专业解析，ModuleFactory 生成模块，Parser 解析源码，最后通过 Template 组合模块，输出打包文件的过程。

直观的理解过程：**webpack 就是打散源码再重组的过程**，能保证代码的完整性及先后顺序。

### webpack 重要概念介绍

### webpack 运行的基本流程

### webpack 的基本原理

1. webpack 的入口 entry，所有的文件都会以此为基础进行构建；
2. 其他相关的文件会由 loader 处理后，给 webpack 处理；
3. 一些通用的工作由专门的 plugin 来处理；
4. 开发服务器 dev-server，用来在本地开发；
   1. 本质上是通过分析文件的 hash，后使用 websocket 来将改变通知到浏览器，实现热更新；
5. webpack Loader 作为 webpack 核心能力之一，其基本工作就是将一个文件以字符串的形式读入，再对其进行语法分析和转换后再交给下一环节处理。
   1. 既然是以字符串形式读入，那修改源码就变得非常简单，结合 webpack 在指定 Loader 时的 test 匹配，可以快速定位到指定类型的文件

### webpack4 和 webpack5 的差异

1. Tree Shaking(强大)；
2. 压缩代码；
   1. 内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，我们不用再下载安装。而且在 mode=“production” 的时候会自动开启 js 压缩功能。
3. 缓存配置；
   1. webpack5 内部内置了 cache 缓存机制。直接配置即可。
4. 输出代码；
   1. webpack5 新增属性 output.ecmaVersion，可以生成 ES5 和 ES6 的代码；
   2. webpack4 只能输出 es5 的代码；

<!-- ### 可以通过如下癌的代码查看看我们执行 webpack 过程中运行了哪一些钩子

```js
const webpack = require('webpack');
// 我们这里的配置文件是一个函数
const webpackConfig = require('./config/webpack.common.js');

const compiler = webpack(webpackConfig());

// 遍历hooks，添加回调，输出`hookName`
Object.keys(compiler.hooks).forEach(hookName => {
  if (compiler.hooks[hookName].tap) {
    compiler.hooks[hookName].tap('anyString', () => {
      console.log(`run -> ${hookName}`);
    });
  }
});

// 触发webpack的编译流程
compiler.run();
``` -->

### 本次借助 webpack 要的问题

使用 webpack 来修改要执行的源码，返回处理过后的代码。因为这个过程是很多插件的基本操作，可以方便我们理解插件的运行逻辑与开发流程。本次主要设计到使用 loader 和 plugin 来修改源代码，并返回结果。
