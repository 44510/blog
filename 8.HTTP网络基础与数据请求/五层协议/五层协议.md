## 五层协议的体系结构

物理层，数据链路层，网络层，传输层和应用层。



### 物理层

计算机的世界里只有0和1，正如你现在所看这篇文章的文字，存储在计算机中也是一大串0和1的组合。

但是这些数字不能在真实的物理介质中传输的，而需要把它转换为光信号或者电信号，所以这一层负责将这些比特流(0101)与光电信号进行转换。

如果没有物理层，那么也就不存在互联网，不存在数据的共享，因为数据无法在网络中流动。



### 数据链路层（连接两个物理地址）

数据在这一层不再是以比特流的形式传输，而是分割成一个一个的帧再进行传输。



### 网络层

如果只有数据链路层没有网络层，数据就只能在同一条链路上传输，不能跨链路传输。

有了网络层，数据便能跨域不同的数据链路传输。

**IP地址**

IP地址又称为**软件地址**，存储在计算机的存储器上，IPv4地址为32位, IPv6地址为128位。

##### IP地址和MAC地址

- 网络层以上使用IP地址，数据链路层以下使用MAC地址
- IP地址是逻辑地址，MAC地址是物理地址
- IP分组中首部的源地址和目的地址在传输中不会改变，MAC帧中首部的源地址和目的地址每到一个路由器会改变一次

**IP地址分类**

IP地址 = {<网络号>, <主机号>}

A类地址 : 0.0.0.0 ~ 127.0.0.0

A类地址 : 0.0.0.0 ~ 127.0.0.0
B类地址 : 128.0.0.0 ~ 191.255.0.0

A类地址 : 0.0.0.0 ~ 127.0.0.0
B类地址 : 128.0.0.0 ~ 191.255.0.0
C类地址 : 192.0.0.0 ~ 223.255.255.0

**划分子网之后的IP地址**

IP地址 = {<网络号>, <子网号>, <主机号>}

例如某单位拥有一个B类IP地址，145.13.0.0，但凡目的地址为145.13.x.x的数据报都会被送到这个网络上的路由器R。

内部划分子网后变成 : 145.13.3.0，145.13.7.0，145.13.21.0。但是对外仍表现为一个网络，即145.13.0.0。

这样路由器R收到报文后, 再根据目的地址发到对应的子网上。

**子网掩码**

一般由一串1和一串0组成，不管网络有没有划分子网，将子网掩码和IP地址做按位与运算即可得出网络地址。

所有的网络都必须使用子网掩码，同时在路由表中必须有子网掩码这一栏，如果一个网络不划分子网，那么该网络的子网掩码就是默认的子网掩码。

A类地址的默认子网掩码为255.0.0.0

A类地址的默认子网掩码为255.0.0.0
B类地址的默认子网掩码为255.255.0.0

A类地址的默认子网掩码为255.0.0.0
B类地址的默认子网掩码为255.255.0.0
C类地址的默认子网掩码为255.255.255.0

尽管划分子网增加了灵活性，但是却减少了能够连接在网络上的主机总数。

**构成超网的IP地址**

IP地址 = {<网络前缀>, <主机号>}

使用网络前缀，无分类域间路由选择CIDR

例如，128.14.35.7/20，意思是前20位为网络前缀，后12位为主机号， 另外，CIDR把网络前缀相同的连续的IP地址组成一个"CIDR地址块"。

地址掩码 : CIDR使用32位的地址掩码, 类似于子网掩码。

**虚拟专用网VPN**

因特网中的所有路由器对该目的地址是专用地址的数据报一律不转发，下面有3种专用地址(虚拟IP地址)

- 10.0.0.0 ~ 10.255.255.255
- 172.16.0.0 ~ 172.31.255.255
- 192.168.0.0 ~ 192.168.255.255

假设现在公司A有一个部门在广州和另一个在上海，而他们在当地都有自己的专用网。那么怎么将这两个专用网连接起来呢?

1. 租用电信的通信线路为本机构专用。但是太贵了
2. 利用公用的因特网当做通信载体，**这就是虚拟专用网VPN**



### 传输层

这一层是重中之重，因为数据链路层，网络层这两层的数据传输都是不可靠的，尽最大能力交付的。

什么意思的？就是它们不负责提交给你的就是正确的数据。然而这一层的TCP协议将要提供可靠传输，

这一层主要重点是两个协议 : UDP 和 TCP

**UDP主要特点 :**

- 无连接
- 尽最大努力交付
- 面向报文: 应用层交下来的报文直接加上UDP头部就往IP层扔, 不合并也不拆分
- 没有拥塞控制
- 支持一对一, 一对多, 多对一和多对多的交互通信
- 首部开销小, 只有8个字节

**TCP主要特点 :**

- 面向连接的运输层协议
- 每一条TCP连接只能有2个端点, TCP是点对点的
- 提供可靠交付
- 全双工通信
- 面向字节流



### Q : 为什么要三次握手, 两次不可以吗?

A : 试想一下, A第一次发送请求连接, 但是在网络某节点滞留了, A超时重传, 然后这一次一切正常, A跟B就愉快地进行数据传输了. 

等到连接释放了以后, 那个迷失了的连接请求突然到了B那, 如果是两次握手的话, B发送确认, 它们就算是建立起了连接了. 

事实上A并不会理会这个确认, 因为我压根没有要传数据啊. 但是B却傻傻地以为有数据要来, 苦苦等待. 结果就是造成资源的浪费.



### Q : 为什么要四次挥手, 而不是两次, 三次?

A : 首先, 由于TCP的全双工通信, 双方都能作为数据发送方. A想要关闭连接, 必须要等数据都发送完毕, 才发送FIN给B. (此时A处于半关闭状态)
然后, B发送确认ACK, 并且B此时如果要发送数据, 就发送(例如做一些释放前的处理)
再者, B发送完数据之后, 发送FIN给A. (此时B处于半关闭状态)
然后, A发送ACK, 进入TIME-WAIT状态
最后, 经过2MSL时间后没有收到B传来的报文, 则确定B收到了ACK了. (此时A, B才算是处于完全关闭状态)





## 应用层

应用层协议最著名的就是HTTP, FTP了，还有一个重要的DNS

### 域名系统(DNS, Domain Name System)

DNS 能将域名(例如, www.jianshu.com)解析成IP地址.

域名服务器分类

- 根域名服务器 : 最高层次的域名服务器
- 顶级域名服务器 : 如其名
- 权限域名服务器 : 负责一个区的应服务器
- 本地域名服务器 : 主机发送DNS查询请求就是发给它

1. 主机向本地域名服务器的查询一般都是采用递归查询

2. 本地域名服务器向根域名服务器的查询通常是采用迭代查询

    递归查询 : B问A广州怎么去, A不知道, A就问C, C不知道就问D...直到知道了再一层一层转告直到A告诉B. 
    迭代查询 : B问A广州怎么去, A不知道, A就告诉你可以去问C, 然后B就去问C, C不知道, C就告诉你可以去问D, 然后B就去问D...直到B知道为止






### HTTP协议

HTTP是面向事务的, 即它传输的数据是一个整体, 要么全部收到, 要么全部收不到. 

每一次HTTP请求就需要建立一次TCP连接和释放TCP连接.

HTTP是无连接, 无状态的. 每一次请求都是作为一次新请求.

HTTP/1.0 缺点 : 无连接, 每一次请求都要重新建立TCP连接, 所以每一次HTTP请求都要花费2倍RTT时间(一次TCP请求, 一次HTTP请求)

HTTP/1.1 : 使用持续连接, 即保持TCP连接一段时间.

```
HTTP/1.1持续工作的两种工作方式 : 非流水线方式和流水线方式
非流水线方式 : 收到一个请求的响应再发下一个请求, 效率低, 浪费资源
流水线方式 : 能够同时发送多个请求, 效率高
```

##### HTTP的GET和POST

GET 请求通常用于查询、获取数据，而 POST 请求则用于发送数据

GET 请求通常用于查询、获取数据，而 POST 请求则用于发送数据
GET 请求的参数在URL中, 因此绝不能用GET请求传输敏感数据, 而POST 请求的参数在请求头中, 安全性略高于GET请求

```
ps : POST请求的数据也是以明文的形式存放在请求头中, 因此也不安全
```

