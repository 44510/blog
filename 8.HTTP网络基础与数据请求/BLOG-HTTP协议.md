---
title: HTTP协议
date: 2017-3-6
tags:
  - HTTP协议
  - HTTP1.1协议
  - HTTP2.0
  - HTTPS
categories:
  - [HTTP, HTTP2.0]
  - [HTTP, HTTPS]
---

## HTTP 协议

HTTP 是超文本传输协议，也就是 **HyperText Transfer Protocol**。

HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。

### http 协议的特点

1. 简单；
2. 灵活和易于扩展：HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充；
3. 应用广泛和跨平台；

4. **无状态**
   1. 好处是：不需要额外的资源来记录状态信息，这能减轻服务器的负担
   2. 坏处是：关联性操作很麻烦，所以就引出了 cookie/session/jwt
5. 明文传输：容易被抓包查看；

### http 常见字段有哪些

1. Host
2. Content-Length 字段
3. Connection: keep-alive
4. Content-Type: text/html; charset=utf-8
5. Accept: `*/*`
6. Content-Encoding: gzip
7. Accept-Encoding: gzip, deflate
8. Server
9. Last-Modified
10. Cache-Control
11. Expires
12. Date

### HTTP request 报文结构是怎样的

[rfc2616](http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html)中进行了定义：

1. 首行是**Request-Line**包括：**请求方法**，**请求 URI**，**协议版本**，**CRLF**
2. 首行之后是若干行**请求头**，包括**general-header**，**request-header**或者**entity-header**，每个一行以 CRLF 结束
3. 请求头和消息实体之间有一个**CRLF 分隔**
4. 根据实际请求需要可能包含一个**消息实体**
   一个请求报文例子如下：

```text
GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1
Host: www.w3.org
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36
Referer: https://www.google.com.hk/
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: authorstyle=yes
If-None-Match: "2cc8-3e3073913b100"
If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT

name=qiu&age=25
```

### HTTP response 报文结构是怎样的

[rfc2616](http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html)中进行了定义：

1. 首行是状态行包括：**HTTP 版本，状态码，状态描述**，后面跟一个 CRLF
2. 首行之后是**若干行响应头**，包括：**通用头部，响应头部，实体头部**
3. 响应头部和响应实体之间用**一个 CRLF 空行**分隔
4. 最后是一个可能的**消息实体**
   响应报文例子如下：

```txt
HTTP/1.1 200 OK
Date: Tue, 08 Jul 2014 05:28:43 GMT
Server: Apache/2
Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT
ETag: "40d7-3e3073913b100"
Accept-Ranges: bytes
Content-Length: 16599
Cache-Control: max-age=21600
Expires: Tue, 08 Jul 2014 11:28:43 GMT
P3P: policyref="http://www.w3.org/2001/05/P3P/p3p.xml"
Content-Type: text/html; charset=iso-8859-1

{"name": "qiu", "age": 25}
```

## http1.1 相对比 http1.0 的提升

[http1.0 短连接与 http1.1 长连接](./imgs/http1.0短连接与http1.1长连接.webp)

1. 长连接
   1. 不必每次发送 http 请求都建立一次 tcp 链接，减少了 TCP 连接的重复建立和断开所造成的额外开销；
   2. keep-live 持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。
2. 支持 管道（pipeline）网络传输
   1. 即可在同一个 TCP 连接里面，**客户端可以发起多个请求**，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。
   2. 同时发出 A 请求和 B 请求，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。

### http 1.1 与 http 1.0 的区别

1. http 1.0 对于每个连接都得建立一次连接, **一次只能传送一个请求和响应**, 请求就会关闭, http1.0 没有 Host 字段；而 http1.1 在**同一个连接（tcp）中可以传送多个请求和响应（Connection: keep-alive）**, 多个请求可以重叠和同时进行, http1.1 必须有 host 字段；
2. http1.1 中引入了 **ETag 头**, 它的值 entity tag 可以用来唯一的描述一个资源. 请求消息中可以使用 If-None-Match 头域来匹配资源的 entitytag 是否有变化；
3. http1.1 新增了 Cache-Control 头域(消息请求和响应请求都可以使用), 它支持一个可扩展的指令子集；
4. http1.0 中只定义了 16 个状态响应码, 对错误或警告的提示不够具体. http1.1 引入了一个 Warning 头域, 增加对错误或警告信息的描述. 且新增了 24 个状态响应码；

## http2.0 相对于 http1.1 的提升

**http2.0 不是 https**，它相当于是 http 的下一代规范（譬如 https 的请求可以是 http2.0 规范的）。

简述下 http2.0 与 http1.1 的**显著不同点**：

1. http1.1 中，每请求一个资源，**都是需要开启一个 tcp/ip 连接的**，所以对应的结果是，每一个资源对应一个 tcp/ip 请求，由于 tcp/ip 本身**有并发数限制**，所以当资源一多，速度就显著慢下来
2. **http2.0 中，一个 tcp/ip 请求可以请求多个资源，也就是说，只要一次 tcp/ip 请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升**。多个请求合成一个。
3. 如果 http2.0 全面应用，**很多 http1.1 中的优化方案就无需用到了**（譬如打包成精灵图，静态资源多域名拆分等）。

**然后简述下 http2.0 的一些特性：**（感觉还需要很久啊）

1. **首部压缩**（http 头部压缩，减少体积）；
   1. HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。
   2. 这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个**索引**号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。
2. **多路复用**（即一个 tcp/ip 连接可以请求多个资源）href||src；
   1. 移除了 HTTP/1.1 中的串行请求，不需要排队等待；
   2. HTTP/2 是可以在一个连接中**并发**多个请求或回应，而**不用按照顺序一一对应**。
3. **二进制分帧**（**在应用层跟传送层之间增加了一个二进制分帧层**，改进传输性能，实现低延迟和高吞吐量）；
   1. HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是**全面采用了二进制格式**。
   2. 头信息和数据体都是二进制，并且统称为帧（frame）：**头信息帧和数据帧**。
4. **服务器端推送**（服务端可以**对客户端的一个请求发出多个响应，可以主动通知客户端 websocket 替代**）；
5. **请求优先级**（如果流**被赋予了优先级**，**它就会基于这个优先级来处理**，由服务器决定需要多少资源来处理该请求。）
6. **数据流**
   1. HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。
   2. 每个请求或回应的所有数据包，称为一个数据流（Stream）
   3. 每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。

## http3.0 ｜ HTTP/2 有哪些缺陷 ｜ HTTP/3 做了哪些优化

1. HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，**就会触发 TCP 的重传机制**，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。

也就是，**丢包重传，会阻塞所有的 http 请求**。

### http3.0

这都是基于 TCP 传输层的问题，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP**！

**UDP 发生是不管顺序，也不管丢包的**，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的一个丢包全部重传问题。

大家都知道 UDP 是不可靠传输的，但基于 UDP 的 **QUIC 协议** 可以实现类似 TCP 的可靠性传输。

1. QUIC 有自己的一套机制**可以保证传输的可靠性的**。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。

2. TL3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack。

3. HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。**QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次**，减少了交互次数。

## HTTPS 及 HTTPS 与 http1.1 的区别 || http 和 https 区别

1. 是否明文传输：
   1. HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。
   2. HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
2. 是否有加密层：

   1. HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。
   2. 而 HTTPS 在 TCP 三次握手之后，**还需进行 SSL/TLS 的握手过程**，才可进入加密报文传输。HTTPS **在 HTTP 与 TCP 层之间**加入了 SSL/TLS 协议。

3. 默认端口：

   1. HTTP 的端口号是 80，
   2. HTTPS 的端口号是 443。

4. 是否需要证书：
   1. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

**如果要将网站升级成 https，需要后端支持（后端需要申请证书等），然后 https 的开销也比 http 要大（因为需要额外建立安全链接以及加密等），**所以一般来说 http2.0 配合 https 的体验更佳（因为 http2.0 更快了）。

### https 的 ssl/tsl 过程 || https 建立的过程

[HTTPS 与 SSL 证书概要](https://www.runoob.com/w3cnote/https-ssl-intro.html)

TLS/SSL 中使用了非对称加密，对称加密以及 HASH 算法。握手过程的具体描述如下：

1. 浏览器将自己支持的一套**加密规则**发送给网站。
2. 网站从中选出一组加密算法与 HASH 算法，并**将自己的身份信息以证书的形式**发回给浏览器。证书里面包含了网站地址，**加密公钥**，以及证书的颁发机构等信息。
3. 浏览器获得网站证书之后浏览器要做以下工作：
   1. 验证证书的**合法性**（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。
   2. 如果证书受信任，或者是用户接受了不受信的证书，**浏览器会生成一串随机数的密码**，**并用证书中提供的公钥加密**。
   3. 使用约定好的 HASH 算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。
4. 网站接收浏览器发来的数据之后要做以下的操作：
   1. 使用自己的**私钥将信息解密取出密码**，**使用密码解密浏览器发来的握手消息**，并验证 HASH 是否与浏览器发来的一致。
   2. 使用密码加密一段握手消息，发送给浏览器。
5. 浏览器解密并计算握手消息的 HASH，如果与服务端发来的 HASH 一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。

这里浏览器与网站**互相发送加密的握手消息并验证**，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。另外，HTTPS 一般使用的加密与 HASH 算法如下：

- 非对称加密算法：RSA，DSA/DSS
- 对称加密算法：AES，RC4，3DES
- HASH 算法：MD5，SHA1，SHA256

## 如何建立长链接 ｜ 实时推送

1. **ajax 轮询**：`http1.0`中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如`1`秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。
2. **http1.1 长连接**：`HTTP1.1`中，通过使用`Connection: keep-alive`进行长连接，。客户端只请求一次，但是服务器会将继续保持连接，**当再次请求时，避免了重新建立连接(复用 tcp 连接)**。
3. [websocket，基于 http 的自定义协议](https://www.runoob.com/html/html5-websocket.html)链接；
   注意，`HTTP 1.1`默认进行持久连接。在一次 `TCP` 连接中可以完成多个 `HTTP` 请求，但是对**每个请求仍然要单独发 header**，`Keep-Alive`不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如`Apache`）中设定这个时间。
4. http2.0，服务器端推送。
