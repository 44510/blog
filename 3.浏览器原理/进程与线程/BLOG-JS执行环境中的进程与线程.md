---
title: JS执行环境中的进程与线程
date: 2020-3-30
tags:
  - 进程
  - 线程
  - 浏览器原理
  - node
categories:
  - [浏览器原理]
  - [node]
  - [进程与进程]
---

[从进程和线程了解浏览器的工作原理](https://www.jianshu.com/p/8ff15d3a1dfd)
[Node.js 进阶之进程与线程](https://blog.csdn.net/Fuohua/article/details/93463116)

进程（process）和线程（thread）是操作系统的基本概念。

JS 的执行环境主要包括：浏览器和 node。

- 进程，对于浏览器来说可以理解为一个个 tab 页面，node 中的一个个 childProcess。
- 线程，是去做具体的事情的工厂。

## 进程

现代操作系统都是可以同时运行**多个任务的**，比如：用浏览器上网的同时还可以听音乐。对于操作系统来说，**一个任务就是一个进程**，比如打开一个浏览器就是启动了一个浏览器进程，打开一个 Word 就启动了一个 Word 进程。

**官方定义**：进程是 CPU **资源分配的最小单位**（是能拥有资源和独立运行的最小单位）。

在 mac 下，同上，可以通过"活动监视器"来查看进程。

## 线程

有些进程同时不止做一件事，比如 Word，它同时可以进行打字、拼写检查、打印等事情。**在一个进程内部，要同时做多件事，就需要同时运行多个“子任务”**，我们把进程内的这些“子任务”称为线程。

由于每个进程至少要做一件事，**所以一个进程至少有一个线程**。

**系统会给每个进程分配独立的内存**，因此进程有它独立的资源。**同一进程内的各个线程之间共享该进程的内存空间（包括代码段，数据集，堆等）。**

**官方定义**：**线程是 CPU 调度的最小单位**（是建立在进程基础上的一次程序运行单位）。

但同一进程中的多个线程有**各自的调用栈（call stack）**，自己的**寄存器环境（register context）(执行环境)**，自己的**线程本地存储（thread-local storage)**，线程又有单线程和多线程之分，具有代表性的 JavaScript、Java 语言。

## 浏览器的模型 ｜ 浏览器的工作原理 ｜ 浏览器中的进程与线程

**浏览器是多进程的**，有一个**主控进程**，以及**每一个 tab 页面都会新开一个进程**（某些情况下多个 tab 会合并进程）。

![浏览器的多进程](../imgs/浏览器的多进程.jpg)
![chrome任务管理器](../imgs/chrome任务管理器.jpg)

### 浏览器包含哪些进程

为了简化理解，这里仅列举主要进程。

- Browser 主进程：浏览器的**主进程，只有一个**。
  - 负责**浏览器界面的显示与交互**；
  - 各个页面（子进程）的管理，创建和销毁其他进程；
  - **网络的资源管理、下载**等。
- Renderer 进程：**也称为浏览器渲染进程或浏览器内核**，内部是**多线程**的。主要负责**页面渲染，脚本执行，事件处理**等。
- 第三方插件进程：**每种类型的插件对应一个进程**，仅当使用该插件时才创建。
- GPU 进程：最多一个，用于 **3D 绘制**等。

### 浏览器多进程的优势有

- 由于默认 新开 一个 tab 页面 新建 一个进程，所以单个 tab 页面崩溃不会影响到整个浏览器；
- 同样，第三方插件崩溃也不会影响到整个浏览器；
- 多进程可以充分利用现代 CPU 多核的优势；
- 方便使用沙盒模型隔离插件等进程，提高浏览器的稳定性。

**系统为浏览器新开的进程分配内存、CPU 等资源**，所以内存和 CPU 的资源消耗也会更大。

### Renderer，浏览器内核（渲染进程）

前面说了这么多的进程，对普通前端操作来说，最重要的还是**渲染进程**。

**浏览器的渲染进程是多线程的**，页面的渲染，JS 的执行，事件的循环等，都在这个进程内执行。

渲染进程通常由以下**常驻线程**组成：

1. **GUI 渲染线程**，负责渲染浏览器界面，**解析 HTML、CSS，构建 DOM tree 和 render tree，布局和绘制等**。当界面需要重绘（repaint）或由于某种操作引发回流（reflow）时，该线程就会执行。
2. **JS 引擎线程**，也称为 JS 内核，**负责解析 JavaScript 脚本**，运行代码。
   1. **JavaScript 是单线程的**。JavaScript 作为浏览器脚本语言，**主要用途是与用户互动以及操作 DOM**。这也决定了它只能是单线程的，否则会带来很复杂的同步问题。
   2. **GUI 渲染线程 与 JS 引擎线程是互斥的**。也就是说在渲染的过程中，需要执行 js 的话，gui 渲染线程就要挂起。**JavaScript 引擎线程和 GUI 渲染线程同时运行**，**浏览器设置 GUI 渲染线程与 JS 引擎为互斥的关系**。当 JS 引擎执行时，GUI 线程被挂起，GUI 更新被保存在一个队列中，等到 JS 引擎线程空闲时立即被执行。
   3. JS 执行阻塞页面加载。**当浏览器在执行 JavaScript 的时候，GUI 渲染线程会被保存在一个队列中，直到 JS 程序执行完成，才会接着执行**。因此如果 JS 执行时间过长，就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
3. **事件触发控制线程**，**当一个事件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎处理**。这些事件可以是当前执行的代码块，如**定时任务**；也可以是来自浏览器内核的其他线程，如：**鼠标点击**、**Ajax 异步请求**等。但由于 JS 是单线程的，这些事件都需要排队等待 JS 引擎处理。
4. **定时触发器线程**，setTimeout 和 setInterval 所在的线程。**浏览器定时计数器并不是由 JS 引擎计数的，因为 JS 是单线程的，如果处于阻塞线程状态就会影响计时的准确**，所以通过单独的线程来计时并触发定时更为合理。
5. **异步 http 请求线程**，XMLHttpRequest 在建立连接后，通过浏览器新开一个线程请求，**一旦检测到状态变更并且设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，等待 JS 引擎空闲时处理**。

### Browser 进程和 Renderer 进程的通信过程

打开浏览器的一个 tab 页时，我们看下其中的大致过程：

1. Browser 进程收到**用户请求**（浏览器主进程管理的输入框，输入地址开始请求），**通过网络下载获取页面内容**，然后将该任务通过**RendererHost 接口**传递给 Renderer 进程（具体的 **tab 的进程下的渲染进程**）；
2. Renderer 进程的 Renderer 接口收到消息，简单解释后，**交给 GUI 渲染线程开始渲染**；
3. GUI 渲染线程接收请求，**加载网页并渲染网页**，这个过程中可能需要 **Browser 进程获取资源**和 **GPU 进程来帮助渲染**，也可能会有 JS 引擎线程操作 DOM（可能造成回流并重绘）；
4. 最后 Renderer 进程**将结果传递给 Browser 进程**；

Browser 进程接收到结果，**并将结果绘制出来**。

到这里应该对浏览器的运作有一定理解了，我们再来看下浏览器是怎么渲染页面的。

### 浏览器的渲染流程，GUI

![浏览器的渲染流程](../imgs/渲染流程图.png)

1. 解析 HTML 文件(Browser 进程下载的)，生成 DOM tree；同时解析 CSS 文件以及样式元素中的样式数据，生成 **CSS Rules**。
2. 合并构建 render tree：根据 DOM tree 和 CSS Rules 来构建 render tree，它可以让浏览器按照正确的顺序绘制内容。
3. 布局（layout / reflow）：计算各元素尺寸、位置。
4. 绘制（paint）：绘制页面像素信息。
5. 浏览器将**各层信息发送给 GPU，GPU 将各层信息合成（composite），显示在屏幕上**。

补充：

Webkit 将 render tree 中的元素称为 **render object （或 renderer）**，每一个 render object 都代表一个的矩形区域，通常对应于相关节点的 CSS 框，这些矩形的排列顺序就是它们在屏幕上显示的顺序。

Render object 和 DOM 节点是相对应的，但并非一一对应。**非可视化的 DOM 元素不会插入 render tree 中**，例如“head”元素 和 一些 display: none 的节点就没必要放在 render tree 中了。

## node 的模型｜ node 中的进程与线程

查`blog/7.Node与服务端开发/node进程间通信/BLOG-node多进程及进程间通信.md`
